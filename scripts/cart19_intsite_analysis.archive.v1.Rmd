---
title: |
    | CART19 Integration Site Analysis:
    | Manuscript Figures
author: "Christopher Nobles, Ph.D. and Frederic Bushman, Ph.D."
date: "generated `r Sys.Date()`"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
    number_sections: false
    toc_depth: 2
    fig_caption: true
    df_print: default
    highlight: espresso
header-includes: 
  - \usepackage{float}
  - \usepackage{indentfirst}
  - \setlength{\defaultaddspace}{0em}
  - \setlength{\parindent}{2em}
fontsize: 11pt
geometry: margin=0.5in
---

```{r setup, include=FALSE}
options(stringsAsFactors = FALSE, scipen = 99)

packs <- c(
  "BiocGenerics", "Biostrings", "GenomicRanges", "geneRxCluster", "hiAnnotator",
  "igraph", "Matrix", "parallel", "reldist", "reshape2", "RMySQL", "data.table",
  "sonicLength", "vegan", "lubridate", "gintools", "spraphal", "ggrepel", 
  "scales", "grid", "gridExtra", "RColorBrewer", "knitr", "magrittr", "pander",
  "KEGGREST", "GO.db", "UpSetR", "BiasedUrn", "foreach", "tidyverse")

packsLoaded <- suppressMessages(
  sapply(packs, require, character.only = TRUE)
)

if( !all(packsLoaded) ){

  pandoc.table(data.frame(
      "R-Packages" = names(packsLoaded), 
      "Loaded" = packsLoaded, 
      row.names = NULL
  ))
  
  stop("Check dependancies.")
  
}

knitr::opts_chunk$set(
  echo = FALSE,
  fig.path = file.path(workingDir, "reports", "manuscript_figures/"),
  fig.align = "center",
  comment = "",
  echo = FALSE,
  warning = FALSE,
  error = TRUE,
  message = FALSE,
  cache = FALSE,
  dpi = 100,
  dev = "pdf",
  results = "asis",
  fig.pos = "H",
  fig.width = 7.5
)

## Processing information ----
genomicFreeze <- "hg38"

analysisDate <- Sys.Date()

trial <- "CART19"
std_clin_trials <- c("959", "04409", "03712")

set.seed(1234)

## Reference and supporting files ----
source(file.path(scriptDir, "supporting_functions.R"))
source(file.path(scriptDir, "supporting_goa_functions.R"))
source(file.path(scriptDir, "GenomicHeatmapMaker/utils.R"))
source(file.path(scriptDir, "EpigeneticHeatmapMaker/utils.R"))

key_gois <- c("TET2")

intsiteSpecimenMetadata <- read.csv(
    file.path(workingDir, "data/cart19_intsite_sample_list.csv")) %>%
  dplyr::mutate(clin_trial = str_extract(Patient_ID, "[0-9]+"))

refGenes <- readRDS(file.path(utilsDir, "hg38.refSeq.rds"))

refGenes <- refGenes[
  seqnames(refGenes) %in% paste0("chr", c(1:22, "X", "Y", "M"))
]

excluded_gene_names <- c(
  "TET2-AS1", "HNRNPUL2-BSCL2", "ANKHD1-EIF4EBP3", "TONSL-AS1", 
  "ATP6V1G2-DDX39B", "C7orf55-LUC7L2"
)

excluded_sites <- c("PCCA" = "chr13-100350286", "NRP1" = "chr10+33114980")

oncoGenesData <- read.delim(
  file.path(utilsDir, "allOnco.human.v3.tsv"),
  header = TRUE, 
  sep = "\t",
  stringsAsFactors = FALSE
)

oncoGenes <- unique(oncoGenesData[,"symbol"])
nonOncoGenes <- unique(refGenes$name2[!refGenes$name2 %in% oncoGenes])

badActors <- read.delim(
  file.path(utilsDir, "humanLymph.v1.list"),
  header = FALSE,
  sep = "\t",
  stringsAsFactors = FALSE
)[,1]

genomic_features_path <- file.path(scriptDir, "GenomicHeatmapMaker")
epigenetic_features_path <- "/data/internal/epigeneticData/hg38" # Not archivable

epigenetic_features_files <- list.files(epigenetic_features_path) %>%
  grep("HeLa", ., invert = TRUE, value = TRUE) %>%
  grep("CD133", ., invert = TRUE, value = TRUE) %>%
  grep("HEK293T", ., invert = TRUE, value = TRUE) %>%
  grep("Jurkat", ., invert = TRUE, value = TRUE) %>%
  file.path(epigenetic_features_path, .)


# Import HGNC reference data for annotation and consistency ----
hgnc_complete <- fread(
  paste0("zcat ", file.path(utilsDir, "hgnc_complete_set.180207.txt.gz")),
  sep = "\t", header = TRUE, 
  select = c(
    "HGNC ID", "Approved Symbol", "Approved Name", "Locus Group", "Locus Type", 
    "Synonyms", "Previous Symbols", "Entrez Gene ID", "Ensembl Gene ID", 
    "RefSeq (supplied by NCBI)", "UniProt ID (supplied by UniProt)"),
  data.table = FALSE
)

names(hgnc_complete) <- c(
  "hgnc_id", "symbol", "name", "locus_group", "locus_type", "alias_symbol", 
  "prev_symbol", "entrez_id", "ensembl_gene_id", "refseq_accession", 
  "uniprot_ids"
)

hgnc_complete <- dplyr::filter(hgnc_complete, !grepl("withdrawn", symbol)) %>%
  dplyr::mutate(
    kegg_id = paste0("hsa:", entrez_id),
    entrez_id = paste0(entrez_id, ":EZID"),
    alias_symbol = gsub(", ", "|", alias_symbol),
    prev_symbol = gsub(", ", "|", prev_symbol),
    extended_alias = paste0(
      alias_symbol, "|", prev_symbol, "|", ensembl_gene_id, "|", 
      refseq_accession, "|", uniprot_ids)
  )

## Develop standard factor scales for celltypes and timepoints ----
celltypeLevels <- c(
  "PB", "PBMC", "PBL", "Whole Blood", "Tcells", "Tcells:CAR+", 
  "Tcells:CAR+CD4+", "Tcells:CAR+CD8+", "Tcells:CAR+CD8-", "Tcells:CAR-CD4+", 
  "Tcells:CD4+SP", "Tcells:CAR-CD8+", "Tcells:CAR-CD8-", "Tcells:CD4+", 
  "Tcells:CD8+", "Tcells:CD8+Naive", "Tcells:CD8+Tscm", "Tcells:CD8+Tcm", 
  "Tcells:CD8+Tem", "Tcells:CD8+Te", "Tcells:CD8+Tm", "Tcells:CD4+CD8+", 
  "Tcells:CD4+CD8+DP", "Tcells:CD4+CD8+DN", "Bone Marrow", "BM", "BMMC", 
  "BM:CAR+", "CD3-"
)

timepointLevels <- c(
  "d-10", "d-1", "d0", "d1", "d5", "d7", "d9", "d10", "d11", "d13", "d14", 
  "d15", "d17", "d21", "d23", "d25", "d28", "d30", "d35", "d36", "d42", "d49",
  "d50", "m2", "d63", "d75", "d90", "m3", "d92", "d120", "d121", "m4", "d133",
  "d147", "m5", "d169", "m6", "d204", "m9", "m12", "y1", "d442", "m15", "m18", 
  "y1.5", "m20", "m21", "d720", "m24", "y2", "d801",  "y2.5", "m32", "y3", 
  "y4", "d1584", "y4.5", "m60", "y5", "y5.5", "y6", "y6.5", "y7", "y8"
)  

# Plot theme ----
custom_theme <- theme_bw() + 
  theme(
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    strip.text = element_text(color = "black", face = "bold"),
    strip.background = element_rect(fill = "white", color = "white"),
    axis.line.x = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.title.y = element_text(color = "black", size = 10),
    axis.title.x = element_text(color = "black", size = 10),
    axis.text.x = element_text(color = "black", size = 10),
    axis.text.y = element_text(color = "black", size = 10),
    legend.text = element_text(color = "black", size = 10),
    legend.title = element_text(color = "black", size = 10),
    plot.title = element_text(color = "black", size = 12)
  )

# Load patient data ----
patient_data <- read.csv(
    file.path(outputDir, "cart19_intsite_sample_list.csv")
  ) %>%
  dplyr::distinct(Patient_ID, Disease, Response_to_Treatment) %>%
  dplyr::rename(
    "patient" = Patient_ID, 
    "disease" = Disease, 
    "response" = Response_to_Treatment
  ) %>%
  dplyr::mutate(
    clin_trial = str_extract(patient, "[0-9]+"),
    patient = gsub("_", "-", patient),
    disease = gsub("Adult ALL", "aALL", disease),
    disease = gsub("Pediatric ALL", "pALL", disease),
    disease = factor(disease, levels = c("pALL", "aALL", "CLL")),
    response = gsub(" but relapse", "\nw relapse", response),
    response = gsub(" - with transformed dz", "\nw TnDz", response),
    response = factor(
      response, 
      levels = c(
        "None", "Partial", "Partial\nw TnDz", 
        "Complete", "Complete\nw relapse")),
    simple_response = factor(
      str_extract(as.character(response), "[\\w]+"), 
      levels = c("None", "Partial", "Complete")),
    general_response = factor(ifelse(
      response == "None", "Non-responder", "Responder"), 
      levels = c("Non-responder", "Responder")),
    determinant_response = factor(ifelse(
      response %in% c("Complete", "Partial\nw TnDz", "Complete\nw relapse"), 
      "CR_PRtd", "PR_NR"), levels = c("CR_PRtd", "PR_NR"))
  ) %>%
  dplyr::arrange(disease, response)

patient_data[patient_data$patient == "p03712-12",]$response <- "None"
patient_data[patient_data$patient == "p03712-12",]$simple_response <- "None"
patient_data[patient_data$patient == "p03712-12",]$general_response <- "Non-responder"

std_clin_patients <- patient_data %>%
  dplyr::filter(clin_trial %in% std_clin_trials) %$%
  patient

CR_pats <- patient_data$patient[patient_data$determinant_response == "CR_PRtd"]
NR_pats <- patient_data$patient[patient_data$determinant_response == "PR_NR"]

## Load integration site analysis data ----
data_files <- list.files(outputDir)


### Load specimen_data
file <- grep("specimen_data", data_files, value = TRUE)
specimen_data <- readRDS(file.path(outputDir, file)) %>%
  dplyr::mutate(
    celltype = ifelse(
      as.character(celltype) == "PBMC", "PBL", as.character(celltype)),
    celltype = factor(celltype, levels = celltypeLevels)
  )

if( !all(patient_data$patient %in% specimen_data$patient) ){
  warning("Not all specimens in database, using custom data.")
  specimen_data <- dplyr::select(
      intsiteSpecimenMetadata, 
      Trial, Patient_ID, Abv_Cell_Type, 
      Sorting_Parameters, Timepoint, GTSP) %>%
    dplyr::rename(
      "trial" = Trial, "patient" = Patient_ID, 
      "timepoint" = Timepoint, "specimenaccnum" = GTSP) %>%       
    dplyr::mutate(
      celltype = ifelse(
        grepl("^s", Abv_Cell_Type),
        paste0(gsub("^s", "", Abv_Cell_Type), ":", Sorting_Parameters),
        Abv_Cell_Type),
      celltype = ifelse(
        as.character(celltype) == "PBMC", "PBL", as.character(celltype)),
      celltype = ifelse(
        as.character(celltype) == "Whole Blood", 
        "PBL", as.character(celltype)),
      celltype = factor(celltype, levels = celltypeLevels),
      timepoint = factor(timepoint, levels = timepointLevels)) %>%
    dplyr::select(trial, patient, celltype, timepoint, specimenaccnum) %>% 
    dplyr::arrange(specimenaccnum)
}


### Load condensed integrations sites
cond_uniq_sites <- readRDS(file.path(outputDir, "condensed_intsites.rds"))


### Load transduction product specific sites in a different format
tdn_sites <- readRDS(file.path(outputDir, "cart19_tdn_sites.rds"))
tdn_sites <- tdn_sites[tdn_sites$patient %in% std_clin_patients]
total_tdn_sites <- length(unique(paste(tdn_sites$patient, tdn_sites$posid)))

total_tdn_sites_CR <- length(unique(paste(
  tdn_sites$patient, tdn_sites$posid)[tdn_sites$patient %in% CR_pats]))

total_tdn_sites_NR <- length(unique(paste(
  tdn_sites$patient, tdn_sites$posid)[tdn_sites$patient %in% NR_pats]))

### Load timepoint or patient specific sites in a different format
timepoint_sites <- readRDS(
  file.path(outputDir, "cart19_timepoint_sites.rds")
)

timepoint_sites <- timepoint_sites[
  timepoint_sites$patient %in% std_clin_patients
]

total_pat_sites <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid
)))

total_pat_sites_CR <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid)[
    timepoint_sites$patient %in% CR_pats
  ]
))

total_pat_sites_NR <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid)[
    timepoint_sites$patient %in% NR_pats
  ]
))


### Load summaries: specimen, patient, timepoint, celltype 
summaries <- readRDS(
  file.path(outputDir, "cart19_summaries.rds")
)


### Load stats about transcription unit regions
gene_impact <- readRDS(
    file.path(outputDir, "cart19_gene_impact.rds")) %>%
  dplyr::select(
    -Within_Cluster, -Cluster_target.min, -ort_fisher_test, -ort_fisher_test_CR,
    -ort_fisher_test_NR) %>%
  dplyr::filter(!gene_name %in% excluded_gene_names) %>%
  dplyr::mutate(gene_name = alias_arbiter(
    IDs = gene_name,
    RefIDs = hgnc_complete$symbol,
    aliasIDs = hgnc_complete$extended_alias,
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE))

goi_data <- read.csv(
    file.path(outputDir, list.files(outputDir, pattern = "cart19_goi_data.csv"))
  ) %>%
  dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name))

goi_lists <- lapply(
  c("Enrichment", "Depletion", "Abundance", "Longitudinal"), 
  function(x) goi_data$Gene_Name[goi_data[, x, drop = TRUE]] 
)

names(goi_lists) <- c("Enrichment", "Depletion", "Abundance", "Longitudinal")

### Load the filtered unique integration sites as a reference
all_sites <- grep("filtered_unique_intsites", data_files, value = TRUE)
all_sites <- readRDS(file.path(outputDir, all_sites))
all_sites <- all_sites[all_sites$specimen %in% cond_uniq_sites$specimen]
all_sites <- all_sites[!generate_posid(all_sites) %in% excluded_sites]
all_sites <- all_sites[!generate_posid(all_sites) %in% potential_mispriming]

```

```{r kegg_pathways, include=FALSE}
# Import KEGG pathways ----
k_list <- keggList("hsa")
k_path <- keggList("pathway", "hsa")

k_pathList <- do.call(c, sapply(
  split(k_path, ceiling(seq_along(k_path)/100)),
  function(x) KEGGREST::keggLink("hsa", names(x))
))

k_pathList <- structure(
  hgnc_complete$symbol[match(k_pathList, hgnc_complete$kegg_id)],
  names = stringr::str_extract(names(k_pathList), "path:[\\w]+$")
)

k_pathList <- k_pathList[k_pathList %in% gene_impact$gene_name]
k_pathList <- split(k_pathList, names(k_pathList))
k_genes <- unique(unlist(k_pathList))

k_path_df <- plyr::ldply(
  k_pathList, 
  function(x){data.frame(gene_sym = x)}, 
  .id = "path"
)

```

```{r go_terms, include=FALSE}
# Import GO Biological Process reference ----
# Construct GO DAG from GO.db
Gobp <- unlist(as.list(GO.db::GOBPCHILDREN)) %>%
  data.frame(
    "vi" = str_extract(names(.), "[\\w:]+"),
    "vj" = .,
    "annotation" = str_extract(names(.), "[\\w]+$")) %>%
  dplyr::filter(!is.na(vj)) %>%
  dplyr::filter(annotation %in% c("is_a", "part_of")) %>%
  construct_graph(E = ., mode = "directed")

ignored_GOTERMs <- names(V(Gobp)[which(layout_as_tree(Gobp)[,2] >= 9)])

Gobp <- induced_subgraph(
  Gobp, names(V(Gobp))[!names(V(Gobp)) %in% ignored_GOTERMs]
)

# Pick up gene product annotations to GO terms (UniProt-GOA)
goa_bpdata <- load_go_gaf(
    paste0("zcat ", file.path(utilsDir, "goa_human.gaf.gz"))
  ) %>% 
  dplyr::mutate(gene_symbol = alias_arbiter(
    IDs = DB_Object_Symbol, 
    RefIDs = hgnc_complete$symbol, 
    aliasIDs = hgnc_complete$extended_alias, 
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE)) %>%
  dplyr::filter(gene_symbol %in% gene_impact$gene_name) %>%
  dplyr::filter(GO_ID %in% V(Gobp)$name)

# Obtain specific (child) GO terms and general (ancestor) GO terms
buster <- makeCluster(numCores)

all_GOBP <- as.list(GO.db::GOBPOFFSPRING)

all_GOBP_list <- parLapply(
  buster, 
  seq_along(all_GOBP), 
  function(i, all_GOBP, goa_bpdata){
    terms <- c(names(all_GOBP[i]), all_GOBP[[i]])
    unique(goa_bpdata$gene_symbol[which(goa_bpdata$GO_ID %in% terms)])
  },
  all_GOBP = all_GOBP, 
  goa_bpdata = goa_bpdata
)

names(all_GOBP_list) <- names(all_GOBP)
all_GOBP_list <- all_GOBP_list[lengths(all_GOBP_list) > 0]
all_GOBP_list <- all_GOBP_list[names(all_GOBP_list) %in% names(V(Gobp))]

all_GOPB_df <- plyr::ldply(
  all_GOBP_list, function(x){data.frame(gene_sym = x)}, .id = "go_term"
)

stopCluster(buster)
go_genes <- unique(unlist(all_GOBP_list))
```

---

\newpage
## Figure 1. Experimental strategy and examples of results.
```{r fig1B, fig.width=7.5, fig.height=3.5}
vcn_summary <- within(
  list(), {
    
    ## Load data
    data_files <- list.files(outputDir)
    file_specimen <- grep("specimen_data", data_files, value = TRUE)
    file_vcn_data <- grep("vcn_data.rds", data_files, value = TRUE)
    specimen_data <- readRDS(file.path(outputDir, file_specimen))
    vcn_data <- readRDS(file.path(outputDir, file_vcn_data))
    
    ## Only work with PB and BM data, other samples are not 
    ## represented in intSites
    vcn_data <- dplyr::filter(vcn_data, type %in% c("PB", "BM")) %>%
      dplyr::mutate(celltype = factor(type, levels = c("PB", "BM"))) %>%
      dplyr::mutate(
        vcn = average.marking.cell,
        cpm = copies.microgram.dna)
    
    ## Identify inflection points that are present in the 
    ## integration sites datasets
    vcn_data$timepoint <- sapply(vcn_data$sample.timepoint, function(x){
      x <- tolower(x)
      if(grepl("day", x)){
        scale <- c("day", "d")
      }else if(grepl("month", x)){
        scale <- c("month", "m")
      }else if(grepl("year", x)){
        scale <- c("year", "y")
      }else{
        scale <- "Undetermined"
        timepoint <- "Undetermined"
      }
      
      if(!scale[1] == "Undetermined"){
        x <- unlist(strsplit(x, " "))
        scale_pos <- grep(scale[1], x)
        time <- as.numeric(x[(scale_pos + 1)])
        timepoint <- paste0(scale[2], time)
      }
      timepoint
    })
    
    specimen_coerce <- dplyr::select(
        specimen_data, patient, timepoint, celltype) %>% 
      dplyr::mutate(celltype = ifelse(
        as.character(celltype) %in% c("PBMC", "PBL", "PB"), 
        "PB", as.character(celltype))) %>%
      dplyr::mutate(timepoint = as.character(timepoint))
    
    vcn_coerce <- dplyr::select(vcn_data, patient, timepoint, celltype) %>%
      dplyr::mutate(celltype = as.character(celltype))
    
    vcn_intsite_intersect <- dplyr::intersect(specimen_coerce, vcn_coerce)
    
    vcn_data$intsite_matched <- with(
      vcn_data, paste(patient, celltype, timepoint)) %in% 
      with(vcn_intsite_intersect, paste(patient, celltype, timepoint))
    
    ## Generate faceted plots for each patient
    vcn_data <- dplyr::select(
        vcn_data, patient, celltype, timeline, vcn, cpm, intsite_matched) %>%
      dplyr::mutate(
        func.time = ifelse(timeline >= 0, timeline, -1.0),
        response = patient_data$determinant_response[
          match(patient, patient_data$patient)],
        resp = patient_data$response[
          match(patient, patient_data$patient)]) %>% 
      as.data.frame()
    
    peak_vcn_data <- vcn_data %>%
      left_join(patient_data, by = "patient") %>%
      dplyr::filter(
        disease == "CLL", func.time >= 10, func.time <= 21, celltype == "PB") %>%
      dplyr::rename("response" = determinant_response) %>%
      dplyr::group_by(patient, response) %>%
      dplyr::arrange(func.time) %>% 
      dplyr::summarise(
        m.cpm = max(cpm), max.func.time = func.time[match(m.cpm, cpm)]) %>% 
      dplyr::ungroup() %>%
      dplyr::mutate(log.m.cpm = log10(m.cpm)) %>%
      dplyr::arrange(m.cpm) %>%
      dplyr::filter(m.cpm >= 10)
    
    peak_vcn_means <- peak_vcn_data %>%
      dplyr::group_by(response) %>%
      dplyr::summarise(
        log.m.cpm = mean(log.m.cpm), 
        max.func.time = mean(max.func.time)) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        m.cpm = 10**log.m.cpm,
        min.time = 10, max.time = 21,
        celltype = "PB")
    
    peak_test <- wilcox.test(
        x = peak_vcn_data$m.cpm[peak_vcn_data$response == "CR_PRtd"], 
        y = peak_vcn_data$m.cpm[peak_vcn_data$response == "PR_NR"])$p.value %>%
      data.frame(
        celltype = "PB", 
        func.time = 180, cpm = 5,
        response = "PR_NR",
        text = paste0(
          "Difference during\npeak expansion\nP-value = ", round(., digits = 5)))
    
    pat_responses <- c("CR_PRtd" = "CR/PRtd", "PR_NR" = "PR/NR")
    
    vcn_data_by_pat <- split(vcn_data, vcn_data$patient)
    
    vcn_data_above <- dplyr::filter(
        vcn_data, cpm >= 10, func.time > 0, celltype == "PB")
    vcn_data_lod <- dplyr::filter(
        vcn_data, cpm < 10, func.time > 0, celltype == "PB") %>%
      dplyr::mutate(cpm = 10)
    
    time_res <- log10(5) + 
      (log10(365) - log10(5)) * seq_len(25)/25
    loess_span <- 0.65
    
    vcn_smooth <- bind_rows(lapply(seq_along(time_res), function(i){
        vcn_dat <- dplyr::filter(vcn_data, func.time >= 7, celltype == "PB")
        time_diff <- mean(unique(diff(time_res)))
        min_time <- max(log10(7), time_res[i] - time_diff)
        max_time <- min(log10(max(vcn_dat$func.time)), time_res[i] + time_diff)
        mid_time <- 10**mean(c(min_time, max_time))
        
        vcn_dat %>%
          dplyr::filter(func.time >= 7, celltype == "PB") %>%
          dplyr::filter(
            log10(func.time) >= min_time, log10(func.time) <= max_time
          ) %>%
          dplyr::group_by(patient, celltype, response, resp) %>%
          dplyr::mutate(cpm = ifelse(cpm < 10, log10(10), log10(cpm))) %>%
          dplyr::summarise(cpm.l = mean(cpm), func.time = mid_time) %>%
          dplyr::group_by(celltype, response, func.time) %>%
          dplyr::summarise(
            cpm.m = sort(cpm.l)[qbinom(p = 0.5, size = n(), prob = 0.5)],
            cpm.lo = sort(cpm.l)[
              max(1, qbinom(p = 0.025, size = n(), prob = 0.5))],
            cpm.hi = sort(cpm.l)[
              min(n(), qbinom(p = 0.975, size = n(), prob = 0.5))],
            pats = n()) %>%
          dplyr::ungroup() %>%
          dplyr::mutate(func.time.l = log10(func.time))
        
        })) %>% 
      dplyr::filter(pats >= 3) %>%
      dplyr::group_by(celltype, response) %>%
      dplyr::mutate(
        cpm.m.sm = predict(
          loess(cpm.m ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l)),
        cpm.lo.sm = predict(
          loess(cpm.lo ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l)),
        cpm.hi.sm = predict(
          loess(cpm.hi ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l))) %>%
      dplyr::ungroup()
    
    vcn_plot <- ggplot() +
      geom_text(
        data = peak_test, 
        aes(x = log10(func.time), y = cpm, label = text)) +
      geom_ribbon(
        data = vcn_smooth, 
        aes(x = func.time.l, ymin = cpm.lo.sm, ymax = cpm.hi.sm), 
        fill = "grey85") +
      geom_line(
        data = vcn_smooth,
        aes(x = func.time.l, y = cpm.m.sm), 
        color = "black", size = 2.0) +
      geom_point(
        data = bind_rows(vcn_data_above, vcn_data_lod),
        aes(x = log10(func.time), y = log10(cpm)), 
        color = "grey50", size = 1.5) +
      geom_hline(
        yintercept = log10(10), linetype = "dotted", 
        color = "grey50", size = 0.5) +
      facet_grid(
        . ~ response, scales = "free", 
        labeller = labeller(response = pat_responses)) +
      scale_color_brewer(palette = "Set1") +
      scale_fill_brewer(palette = "Set1") +
      scale_x_continuous(
        limits = log10(c(6, 365)),
        breaks = log10(c(7, 14, 30, 60, 120, 365)), 
        labels = c("1w", "2w", "1m", "2m", "4m", "1y")) +
      scale_y_continuous(
        limits = c(0.9, 5.65),
        breaks = seq(1, 5, 1), 
        labels = c("LOD", seq(2, 5, 1))) + 
      coord_cartesian(xlim = log10(c(5, 365))) +
      theme_bw() + 
      custom_theme +
      theme(legend.position = "none") +
      labs(
        x = "Treatment time",
        y = "Vector copies per microgram of DNA (Log)")
      
    vcn_plots_by_pat <- lapply(vcn_data_by_pat, function(data){
      p <- ggplot(data, aes(func.time, log10(cpm), color = celltype)) +
        geom_line() +
        scale_y_continuous(        
          breaks = seq(1, 5, 1), 
          labels = c("LOD", seq(2, 5, 1))) + 
        theme_bw() +
        labs(
          title = unique(data$patient), 
          x = "Treatment time (d)", 
          y = "Vector copies per microgram of DNA (Log)",
          color = "CellType")
      
      if(nrow(data[data$intsite_matched,]) > 0){
        p <- p + 
          geom_point(
            data = data[data$intsite_matched == TRUE,], 
            aes(func.time, log10(cpm), fill = celltype), 
            shape = 21, size = 4, color = "white") + 
          labs(fill = "IntSite\nMatched")
      }
      p
    })
  }
)

vcn_summary$vcn_plot
```
Figure 1B. B) Vector copy number (VCN) data from peripheral blood samples taken from CR/PRtd or PR/NR patients compared longitudinally over 3 years. Black line through data indicates moving average of data while surrounding grey area indicates 95% confidence interval. Data below 10 copies per microgram was considered below the limit of detection (LOD). Peak expansion was assessed as maximal VCN within peripherial blood for each patient during 10 to 21 days post-infusion, significant difference between outcome groups was tested by a two-tailed Wilcoxon test.

```{r specimen_barplots}
intsite_barplots <- within(
  list(), {

    # Barplot data generation
    cond_sites <- cond_uniq_sites
    barplot_sites_list <- split(cond_sites, cond_sites$patient)
    num_top_genes <- 100
    
    barplot_list <- lapply(barplot_sites_list, function(sites, num_top_genes){
      
      sites <- sites[order(sites$relAbund, decreasing = TRUE),]
      most_abund_pos_ids <- head(unique(sites$posid), n = num_top_genes)
      
      cutoff <- sites$estAbund[
        match(tail(most_abund_pos_ids, n = 1), sites$posid)]
      
      barplot.df <- data.frame(
        "specimen" = sites$specimen,
        "patient" = sites$patient,
        "timepoint" = factor(sites$timepoint, levels = timepointLevels),
        "celltype" = factor(sites$celltype, levels = celltypeLevels),
        "posid" = sites$posid,
        "gene_id" = sites$gene_id,
        "abund" = sites$estAbund,
        "relabund" = sites$relAbund,
        stringsAsFactors = FALSE
      )
      
      barplot.df$bp_id <- ifelse(
        barplot.df$posid %in% most_abund_pos_ids, 
        barplot.df$gene_id, 
        "LowAbund")
      
      bp_lookup_tbl <- dplyr::distinct(barplot.df, posid, bp_id) %>%
        dplyr::group_by(bp_id) %>%
        dplyr::mutate(bp_id2 = ifelse(
          n() <= 1 | bp_id == "LowAbund",
          bp_id,
          paste0(bp_id, "(", seq_len(n()), ")"))) %>%
        dplyr::ungroup()
      
      barplot.df$bp_id <- bp_lookup_tbl$bp_id2[
        match(barplot.df$posid, bp_lookup_tbl$posid)]

      barplot.df <- dplyr::group_by(barplot.df, specimen) %>%
        dplyr::mutate(specimen_sites = n_distinct(posid)) %>%
        dplyr::mutate(inferred_cells = sum(abund)) %>%
        dplyr::ungroup(.) %>%
        dplyr::mutate(site_bp_id = ifelse(
          bp_id == "LowAbund", "LowAbund", paste0(posid, "^", gene_id))) %>%
        dplyr::group_by(specimen, site_bp_id) %>%
        dplyr::mutate(bp_abund = sum(abund)) %>%
        dplyr::mutate(bp_relabund = sum(relabund)) %>%
        dplyr::ungroup() %>%
        dplyr::group_by(bp_id) %>%
        dplyr::mutate(bp_id2 = ifelse(
          n_distinct(site_bp_id) > 1, 
          paste0(bp_id, "(", match(site_bp_id, unique(site_bp_id)), ")"),
          bp_id)) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(bp_id = bp_id2) %>%
        dplyr::select(-abund, -relabund, -gene_id, -posid, -site_bp_id, -bp_id2) %>%
        dplyr::mutate(bp_id = factor(bp_id)) %>%
        dplyr::distinct(.)
      
      colors_bp <- colorRampPalette(
        brewer.pal(n = 8, name = "Dark2"))(length(levels(barplot.df$bp_id)))  #Color Palette
      bpColors <- structure(colors_bp, names = levels(barplot.df$bp_id))
      bpColors["LowAbund"] <- "#E0E0E0"
      barplot.df$bp_colors <- bpColors[barplot.df$bp_id]
      list(barplot.df, cutoff)
      
      },
      num_top_genes = num_top_genes
    )
    
    barplots <- lapply(barplot_list, function(list){
      
      cutoff <- list[[2]]
      data <- list[[1]]
      
      data <- dplyr::arrange(data, desc(bp_abund)) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = gsub("Whole Blood", "PBL", celltype),
          celltype = gsub("Bone Marrow", "BM", celltype),
          celltype = factor(celltype, levels = celltypeLevels),
          celltype = fct_relevel(fct_drop(celltype), "Tcells"),
          bp_id = fct_relevel(fct_drop(bp_id), unique(as.character(bp_id))),
          timepoint = fct_drop(timepoint)) %>%
        dplyr::arrange(bp_id) %>%
        dplyr::mutate(
          bp_id = fct_relevel(bp_id, sort(as.character(levels(bp_id)))),
          bp_id = fct_relevel(bp_id, "LowAbund"))

      data <- bind_rows(
        dplyr::filter(data, bp_id != "LowAbund"),
        dplyr::filter(data, bp_id == "LowAbund")
      )

      gtsp_order <- dplyr::arrange(data, timepoint, celltype) %>%
        dplyr::distinct(
          specimen, celltype, timepoint, specimen_sites, inferred_cells) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = factor(celltype, levels = celltypeLevels),
          label = paste0(celltype, "\n", inferred_cells),
          specimen = factor(
            as.character(specimen), levels = unique(as.character(specimen))))

      data$specimen <- factor(
        data$specimen, levels = levels(gtsp_order$specimen))

      patient <- unique(data$patient)

      specimen_label <- function(x){
        as.character(gtsp_order[match(x, gtsp_order$specimen), "label"])}

      ggplot() +
        geom_bar(
          data = data, aes(specimen, bp_relabund, fill = bp_id), 
          stat = "identity") +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.12, nrow(gtsp_order)), label = celltype), 
          size = 4) +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.08, nrow(gtsp_order)), label = inferred_cells), 
          size = 4) +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.04, nrow(gtsp_order)), label = specimen_sites), 
          size = 4) +
        facet_grid(. ~ celltype, scales = "free", space = "free") +
        scale_fill_manual(values = data[
          match(levels(data$bp_id), as.character(data$bp_id)),]$bp_colors) +
         scale_x_discrete(breaks = gtsp_order$specimen, labels = gtsp_order$timepoint) +
        labs(y = "Relative Abundance", x = "Timepoint", fill = "GeneNames",
          title = paste0(patient, " Rel. Abund. Barplot (cutoff = ", cutoff, " cells)")) +
        scale_y_continuous(
          breaks = c(0, 0.25, 0.5, 0.75, 1.0), 
          labels = scales::percent) +
        guides(fill = guide_legend(
            reverse = FALSE, ncol = 7,
            label.theme = element_text(angle = 0, color = "black", size = 10),
            title.theme = element_text(angle = 0, color = "black", size = 10))) +
        theme(
          axis.text.x = element_text(
            angle = 45, hjust = 1, vjust = 1, color = "black", size = 12),
          axis.text.y = element_text(color = "black", size = 12),
          axis.title.x = element_text(color = "black", size = 12),
          axis.title.y = element_text(color = "black", size = 12),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
            legend.position = "bottom") #+
        #annotate("text", x = rep(0.63, 3), y = c(1.12, 1.08, 1.04),
        #         label = c("CellType:", "Cells:", "Sites:"), size = 4)
    })
  }
)
```

```{r fig1C, fig.width=5, fig.height=5}
response_barplot <- within(
  list(), {

    pats_list <- c("p04409-09", "p04409-22", "p04409-12", "p04409-18")
    resp_list <- structure(
      c("CR", "PRtd", "PR", "NR"),
      names = pats_list)
    resp_list <- factor(resp_list, levels = unique(resp_list))
    initial_data <- intsite_barplots$barplot_list[pats_list]
    curated_data <- bind_rows(lapply(initial_data, function(x){
      data <- x[[1]] %>%
        dplyr::arrange(desc(bp_abund)) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = gsub("Whole Blood", "PBL", celltype),
          celltype = gsub("Bone Marrow", "BM", celltype)) %>%
        dplyr::filter(celltype %in% c("Tcells", "PBL")) %>%
        dplyr::filter(as.integer(timepoint) %in% c(3, 17, 24, 35, 39, 40)) %>%
        dplyr::mutate(cutoff = x[[2]]) %>%
        dplyr::arrange(bp_id)

      bind_rows(
        dplyr::filter(data, bp_id != "LowAbund"),
        dplyr::filter(data, bp_id == "LowAbund"))
      })) %>%
      dplyr::mutate(
        resp = resp_list[patient],
        bp_id = factor(bp_id, sort(unique(bp_id))),
        bp_id = fct_relevel(bp_id, "LowAbund"),
        timepoint = fct_drop(timepoint),
        celltype = factor(celltype, levels = celltypeLevels),
        celltype = fct_drop(celltype),
        celltype = fct_relevel(celltype, "Tcells"))

    gtsp_order <- dplyr::arrange(curated_data, timepoint, celltype) %>%
      dplyr::distinct(
        specimen, patient, celltype, 
        timepoint, specimen_sites, inferred_cells) %>%
      dplyr::mutate(
        resp = resp_list[patient],
        patient = factor(patient, pats_list),
        celltype = gsub("PBMC", "PBL", celltype),
        celltype = factor(celltype, levels = levels(curated_data$celltype)),
        label = paste0(celltype, "\n", inferred_cells),
        specimen = factor(
          as.character(specimen), levels = unique(as.character(specimen))))
      
    curated_data$specimen <- factor(curated_data$specimen, gtsp_order$specimen)
    curated_data$patient <- factor(curated_data$patient, pats_list)
    
    specimen_label <- function(x){
      as.character(gtsp_order[match(x, gtsp_order$specimen), "label"])}
    
    barplot <- ggplot() +
      geom_bar(
        data = curated_data, 
        aes(x = timepoint, y = bp_relabund, fill = bp_id), 
        stat = "identity") +
      facet_grid(
        resp + patient ~ celltype, 
        scales = "free", space = "free") +
      scale_fill_manual(values = curated_data$bp_colors[match(
        levels(curated_data$bp_id), 
        as.character(curated_data$bp_id))]) +
      labs(y = "Relative Abundance", x = "Timepoint", fill = NULL) +
      scale_y_continuous(
        breaks = c(0, 0.25, 0.5, 0.75, 1.0), labels = scales::percent) +
      custom_theme +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "none",
        strip.text.y = element_text(angle = 0, face = "plain", size = 11),
        strip.text.x = element_text(face = "plain", size = 10),
        panel.background = element_rect(color = "black"))
    
    # Chao1 plot: 4.5" x 3.5"
    
    chao1_plot <- dplyr::filter(
        summaries$specimen, specimen %in% curated_data$specimen) %>%
      dplyr::select(specimen, numUniqSites, Chao1) %>%
      dplyr::mutate(
        Chao1 = ifelse(Chao1 < numUniqSites, numUniqSites, Chao1),
        logChao1 = log(Chao1, base = 10)) %>%
      left_join(curated_data, ., by = "specimen") %>%
      dplyr::distinct(specimen, patient, timepoint, celltype, Chao1, logChao1) %>%
      ggplot(aes(x = timepoint, y = logChao1, group = patient)) +
      geom_line(color = "black") +
      geom_point(color = "white", size = 3) +
      geom_point(color = "blue", size = 2) +
      facet_grid(resp + patient ~ ., scales = "free") +
            labs(y = "Log(Chao1)", x = "Timepoint", fill = NULL) +
      scale_y_continuous(breaks = pretty_breaks(n = 3)) +
      custom_theme +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        legend.position = "none",
        strip.text.y = element_text(angle = 0),
        panel.background = element_rect(color = "black"))

  }
)
response_barplot$barplot
```
Figure 1C. C) Representative barplots from different clinical response groups showing the proportion of the most abundant 100 clones from each patient measured by SonicAbundance. T cells at day 0 indicate the analysis of the pre-infusion product, while other samples were collected post-infusion from peripherial blood (PBL). Each color indicates a different clone within a single patient while the height of the color indicating the relative abundance of the clone within that sample. No clones were shared across patients. Light grey indicates the remaining clones binned as low abundance and their proportion of the population. 

\newpage
## Figure 2. Clonal expansionin CART19-modified cells assessed by tracking sites of integrated vectors.
```{r clonal_skewing_across_patients}
intsite_clone_skew_plots <- within(
  list(), {
    # Generate plots of site abundance distributions
    cutoff <- 1 # percent
    
    tp_high_abund_posids <- get_top_sites(timepoint_sites, cutoff, "estAbund")
    timepoint_sites$abund_status <- ifelse(
      timepoint_sites$posid %in% tp_high_abund_posids,
      "High Abundance", "Low Abundance")
    
    abund_cutoff <- timepoint_sites %>% 
      as.data.frame(row.names = NULL) %>% 
      dplyr::filter(abund_status == "High Abundance") %>% 
      dplyr::group_by(posid) %>% 
      top_n(1, estAbund) %>% 
      dplyr::ungroup() %$% 
      min(estAbund)
    
    high_sites <- timepoint_sites[
      timepoint_sites$abund_status == "High Abundance"]
    low_sites <- timepoint_sites[
      timepoint_sites$abund_status == "Low Abundance"]
    
    tp_df <- as.data.frame(timepoint_sites, row.names = NULL)
    tp_df <- tp_df[order(tp_df$estAbund, decreasing = TRUE),] %>% 
      dplyr::filter(!duplicated(posid)) 
    tp_high_and_low_abund_plot <- ggplot(
        tp_df, aes(x = 1:nrow(tp_df), y = estAbund)) +
      geom_point(aes(color = factor(abund_status))) +
      geom_text_repel(
        data = tp_df[1:10,], 
        aes(x = 1:10, y = estAbund, label = gene_id_wo_annot),
        segment.alpha = 0.5, nudge_x = 10000, size = 2.5, max.iter = 5000) +
      scale_x_continuous(breaks = seq(0, 45000, 15000), labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "X. Patient Specimens",
        x = "Ordered integration sites",
        y = "Sonic abundance",
        color = "") +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 9, face = "bold"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "bold")) +
      annotate("text", x = 30000, y = 11, size = 3,
               label = paste0(
                 "Highly Abundant\nUnique Sites: ", 
                 length(unique(high_sites$posid)))) +
      annotate("text", x = 30000, y = 3, size = 3,
               label = paste0(
                 "Low Abundant\nUnique Sites: ", 
                 format(length(unique(low_sites$posid)), big.mark = ",")))

    ## Now for TDN specimens
    tdn_sites$abund_status <- ifelse(
      tdn_sites$estAbund >= abund_cutoff, "High Abundance", "Low Abundance")

    tdn_high_sites <- tdn_sites[tdn_sites$abund_status == "High Abundance"]
    tdn_low_sites <- tdn_sites[tdn_sites$abund_status == "Low Abundance"]

    tdn_df <- as.data.frame(tdn_sites, row.names = NULL)
    tdn_df <- tdn_df[order(tdn_df$estAbund, decreasing = TRUE),] %>% 
      dplyr::filter(!duplicated(posid))
    tdn_high_and_low_abund_plot <- ggplot(
        tdn_df, aes(x = 1:nrow(tdn_df), y = estAbund)) +
      geom_point(aes(color = factor(abund_status))) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "A. TDN Products",
        x = "Ordered integration sites",
        y = "Sonic abundance",
        color = "") +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain"))

    ## Day 28 only
    d28_sites <- timepoint_sites[timepoint_sites$timepoint == "d28"]
    d28_sites$abund_status <- ifelse(d28_sites$estAbund >= abund_cutoff,
                                     "High Abundance", "Low Abundance")
    d28_sites$determinant_response <- patient_data$determinant_response[
      match(d28_sites$patient, patient_data$patient)]
    
    d28_high_sites <- d28_sites[d28_sites$abund_status == "High Abundance"]
    d28_low_sites <- d28_sites[d28_sites$abund_status == "Low Abundance"]
    
    d28_df <- as.data.frame(d28_sites, row.names = NULL)
    d28_df <- d28_df[order(d28_df$estAbund, decreasing = TRUE),] %>% 
      dplyr::filter(!duplicated(posid))
    
    d28_CR_PRtd <- d28_df %>%
      dplyr::filter(determinant_response == "CR_PRtd")
    
    d28_PR_NR <- d28_df %>%
      dplyr::filter(determinant_response == "PR_NR")
    
    d28_CR_PRtd_abund_plot <- ggplot(
        d28_CR_PRtd, aes(x = seq_len(nrow(d28_CR_PRtd)), y = estAbund)) +
      geom_point(aes(color = factor(abund_status))) +
      geom_text_repel(
        data = d28_CR_PRtd[1:10,], 
        aes(x = 1:10, y = estAbund, label = gene_id_wo_annot),
        segment.alpha = 0.5, size = 3, nudge_x = 2000) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "B. CR/PRtd - Day 28",
        x = "Ordered integration sites",
        y = " ",
        color = "") +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain"))


    d28_PR_NR_abund_plot <- ggplot(
        d28_PR_NR, aes(x = seq_len(nrow(d28_PR_NR)), y = estAbund)) +
      geom_point(aes(color = factor(abund_status))) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "C. PR/NR - Day 28",
        x = "Ordered integration sites",
        y = " ",
        color = "") +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain"))

        
    ## Responders to non-responders
    mod_gene_impact <- gene_impact %>%
      dplyr::filter(TP_num_sites > 0) %>% 
      dplyr::mutate(
        TP_peak_abund_CR = ifelse(
          TP_peak_abund_CR == 0, 0.5, TP_peak_abund_CR),
        TP_peak_abund_NR = ifelse(
          TP_peak_abund_NR == 0, 0.5, TP_peak_abund_NR),
        TP_sum_abund_CR = ifelse(
          TP_sum_abund_CR == 0, 0.5, TP_sum_abund_CR),
        TP_sum_abund_NR = ifelse(
          TP_sum_abund_NR == 0, 0.5, TP_sum_abund_NR))
    
    peak_abund_bivar <- ggplot() +
      geom_abline(slope = 1, intercept = 0, color = "grey50") +
      geom_count(
        data = mod_gene_impact, 
        aes(x = TP_peak_abund_NR, y = TP_peak_abund_CR, color = abund_gini)) +
      scale_y_log10(
        breaks = c(0.5, 1, 10, 100, 1000), 
        labels = c("0", "1", "10", "100", "1,000")) + 
      scale_x_log10(
        breaks = c(0.5, 1, 10, 50), labels = c("0", "1", "10", "50")) +
      scale_size_continuous(trans = "log10") +
      coord_cartesian(ylim = c(0.5, 1500)) +
      geom_text_repel(
        data = dplyr::filter(
          mod_gene_impact, TP_peak_abund_CR >= 120 | TP_peak_abund_NR >= 15), 
        aes(x = TP_peak_abund_NR, y = TP_peak_abund_CR, label = gene_name),
        segment.alpha = 0.5, size = 2, nudge_x = 0.2, nudge_y = 0.25) +
      labs(
        x = "Peak Clonal Abundance\nfor PR/NR Patients",
        y = "Peak Clonal Abundance\nfor CR/PRtd Patients",
        color = "Abund.\nGini", size = "Gene\nCount") +
      custom_theme
      
    sum_abund_bivar <- ggplot() +
      geom_abline(slope = 1, intercept = 0, color = "grey50") +
      geom_count(
        data = mod_gene_impact, 
        aes(x = TP_sum_abund_NR, y = TP_sum_abund_CR, color = abund_gini)) +
      scale_y_log10(
        breaks = c(0.5, 1, 10, 100, 1000), 
        labels = c("0", "1", "10", "100", "1,000")) + 
      scale_x_log10(
        breaks = c(0.5, 1, 10, 50), labels = c("0", "1", "10", "100")) +
      scale_size_continuous(trans = "log10") +
      coord_cartesian(ylim = c(0.5, 2000)) +
      geom_text_repel(
        data = dplyr::filter(
          mod_gene_impact, TP_sum_abund_CR >= 200 | TP_sum_abund_NR >= 25), 
        aes(x = TP_sum_abund_NR, y = TP_sum_abund_CR, label = gene_name),
        segment.alpha = 0.5, size = 2, nudge_x = 0.2, nudge_y = 0.25) +
      labs(
        x = "Cumulative Clonal Abundance\nfor PR/NR Patients",
        y = "Cumulative Clonal Abundance\nfor CR/PRtd Patients",
        color = "Abund.\nGini", size = "Gene\nCount") +
      custom_theme
    
    
  }
)
``` 

```{r fig2ABC, fig.width=7, fig.height=3}
grid.arrange(
  grobs = list(
    intsite_clone_skew_plots$tdn_high_and_low_abund_plot,
    intsite_clone_skew_plots$d28_CR_PRtd_abund_plot,
    intsite_clone_skew_plots$d28_PR_NR_abund_plot), 
  nrow = 1)
```
Figure 2ABC. A-C) Rank-ordered plots display the abundance of each identified clone from their respective groups – transduction (TDN) products, CR/PRtd – Day 28, and PR/NR – Day 28. Highly abundant clones were determined by identifying a cutoff abundance value for the top 1% of all expanded clones within patients, cutoff = 9 cells. Clones at or above this cutoff are colored red, and the top 10 most abundant clones are labeled with their proximal gene symbol.

```{r fig2D, fig.width=5, fig.height=4}
gene_freq_bivar <- within(
  list(), {
    
    freq_bivar <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(id = 1:n()) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(freq_fisher_test = fisher.test(
        matrix(
          c(TDN_num_sites, TP_num_sites, 
            total_tdn_sites - TDN_num_sites, total_pat_sites - TP_num_sites), 
          ncol = 2))$p.value) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_test, method = "BH"))
      
    key_enrich_freq_genes <- dplyr::filter(
        freq_bivar, adj_freq_test <= 0.05, pct_chg > 0
      ) %>%
      dplyr::arrange(adj_freq_test) %>%
      head(n = 10)

    key_deplet_freq_genes <- dplyr::filter(
        freq_bivar, adj_freq_test <= 0.05, pct_chg < 0
      ) %>%
      dplyr::arrange(adj_freq_test) %>%
      head(n = 10)

    plot <- ggplot() +
      geom_abline(slope = 1, intercept = 0) +
      geom_point(
        data = freq_bivar, 
        aes(x = TDN_freq, y = TP_freq, 
            size = TP_num_sites, color = freq_fisher_test)) +
      geom_point(
        data = dplyr::filter(freq_bivar, adj_freq_test <= 0.05, pct_chg > 0),
        aes(x = TDN_freq, y = TP_freq, size = TP_num_sites),
        shape = 21, color = "blue") +
      geom_point(
        data = dplyr::filter(freq_bivar, adj_freq_test <= 0.05, pct_chg < 0),
        aes(x = TDN_freq, y = TP_freq, size = TP_num_sites),
        shape = 21, color = "red") +
      geom_text_repel(
        data = key_enrich_freq_genes,
        aes(x = TDN_freq, y = TP_freq, label = gene_name),
        nudge_x = -0.5, nudge_y = 1, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3) +
      geom_text_repel(
        data = key_deplet_freq_genes,
        aes(x = TDN_freq, y = TP_freq, label = gene_name),
        nudge_x = 0.5, nudge_y = -1, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3) +
      scale_color_continuous(low = "#56B1F7", high = "#132B43") +
      scale_y_continuous(
        trans = log_trans(), 
        breaks = log_breaks(), 
        labels = scales::scientific) +
      scale_x_continuous(
        trans = log_trans(), 
        breaks = log_breaks(), 
        labels = scales::scientific) +
      labs(
        x = "Transduction Product Integration\nFrequency (1 / kb)",
        y = "Patient Sample Integration Frequency (1 / kb)",
        color = "Enriched\nP-value",
        size = "Number of\nIntegrations") +
      custom_theme +
      theme(
        legend.position = "right", 
        legend.box = "vertical",
        legend.direction = "vertical",
        axis.line = element_line(color = "black"))
    
})

gene_freq_bivar$plot
```
Figure 2D. D) Bivariate plot comparing the integration frequency within transcription units of transduction products (x-axis) versus all patient samples. Color indicates the significance of enrichment or depletion of integration within the transcription unit. The top 10 gene symbols representing the transcription units are labeled. 

```{r fig2E, fig.width=3, fig.height=3.5}
tet2_resp <- within(
  list(), {
    freq_rank <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10,
        freq_diff > 0) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(id = seq_len(n())) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(fisher_test = {
        test <- fisher.test(
          matrix(
            c(TP_num_sites, total_pat_sites - TP_num_sites,
              TDN_num_sites, total_tdn_sites - TDN_num_sites), 
            ncol = 2))
        paste(
          c(test$p.value, test$estimate, as.numeric(test$conf.int)), 
          collapse = ":") }) %>%
      dplyr::ungroup() %>%
      tidyr::separate(
        col = fisher_test, 
        into = c("freq_fisher_pval", "freq_odds_ratio", 
                 "freq_conf_low", "freq_conf_high"), 
        sep = fixed(":"), remove = TRUE, convert = TRUE) %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_pval, method = "BH")) %>%
      dplyr::arrange(freq_fisher_pval) %>%
      dplyr::mutate(id = seq_len(n()))
    
    freq_rank_wo_TET2_clone <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10,
        freq_diff > 0) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(
        TP_num_sites = ifelse(
          gene_name == "TET2", TP_num_sites - 1, TP_num_sites),
        id = seq_len(n())) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(fisher_test = {
        test <- fisher.test(
          matrix(
            c(TP_num_sites, total_pat_sites - TP_num_sites,
              TDN_num_sites, total_tdn_sites - TDN_num_sites), 
            ncol = 2))
        paste(
          c(test$p.value, test$estimate, as.numeric(test$conf.int)), 
          collapse = ":") }) %>%
      dplyr::ungroup() %>%
      tidyr::separate(
        col = fisher_test, 
        into = c("freq_fisher_pval", "freq_odds_ratio", 
                 "freq_conf_low", "freq_conf_high"), 
        sep = fixed(":"), remove = TRUE, convert = TRUE) %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_pval, method = "BH")) %>%
      dplyr::arrange(freq_fisher_pval) %>%
      dplyr::mutate(id = seq_len(n()))

    TET2_labels <- bind_rows(
        dplyr::filter(freq_rank, gene_name == "TET2"),
        dplyr::filter(freq_rank_wo_TET2_clone, gene_name == "TET2") %>%
          dplyr::mutate(gene_name = "TET2*"))
    # 4.5"x4.5"
    rank_order_plot <- freq_rank %>%
      dplyr::filter(freq_fisher_pval <= 0.05) %>%
      ggplot(aes(x = id, y = freq_odds_ratio)) +
      geom_point(
        aes(fill = freq_fisher_pval, size = TP_num_sites),
        color = "white", shape = 21) +
      geom_point(
        data = TET2_labels, 
        aes(fill = freq_fisher_pval, size = TP_num_sites), 
        color = "red", shape = 21) +
      geom_text_repel(
        data = TET2_labels,
        aes(label = gene_name), 
        nudge_x = 5, nudge_y = 1.0, segment.alpha = 0.5, 
        arrow = arrow(length = unit(0.05, "inches"))) +
      scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
      guides(
        size = guide_legend(
          override.aes = list(color = "white", fill = "black"))) +
      labs(
        x = "Rank Order", 
        y = "Odds Ratio", 
        fill = "P-value", 
        size = "Identified\nClones") +
      custom_theme +
      theme(
        axis.line = element_line(color = "black"),
        legend.position = "right",
        legend.direction = "vertical", legend.box = "vertical")
    
    # 3"x3.5"
    tet2_resp_plot <- TET2_labels %>%
      dplyr::mutate(gene_name = ifelse(
        gene_name == "TET2", 
        "TET2\nwith\npatient 10", "TET2\nwithout\npatient 10")) %>%
      ggplot(aes(x = gene_name, y = freq_odds_ratio)) +
      geom_bar(stat = "identity", fill = "grey75", color = "black") +
      geom_point() +
      geom_linerange(aes(ymin = freq_conf_low, ymax = freq_conf_high)) +
      geom_hline(yintercept = 1.0, linetype = "dotted") +
      geom_hline(yintercept = 0.0) +
      labs(x = NULL, y = "Odds Ratio") +
      custom_theme +
      theme(
        axis.line.y = element_line(color = "black", size = 0.5),
        axis.line.x = element_blank(), 
        axis.ticks.x = element_blank())
  }
)

tet2_resp$tet2_resp_plot
```
Figure 2E. TET2 frequency differential

\newpage
## Figure 3. Pathways marked by vector integration.
```{r fig3AB, fig.width=9, fig.height=6, eval=TRUE}
go_kegg_heatmaps <- within(
  list(), {

    # Filter down terms (GO and KEGG) that will be relavent to the analysis
    num_terms <- 20
    select_GOBP_list <- all_GOBP_list[
      lengths(all_GOBP_list) >= 10 & lengths(all_GOBP_list) <= 1000]
    select_go_terms <- data.frame(
        id = names(select_GOBP_list), 
        size = lengths(select_GOBP_list)) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(term = Term(GOTERM[[id]])) %>%
      dplyr::ungroup() %>%
      dplyr::filter(
        !grepl("placenta", term),
        !grepl("^negative", term),
        !grepl("^positive", term),
        !grepl("embryo", term),
        !grepl("estrous", term),
        !grepl("eating", term),
        !grepl("reproductive", term),
        !grepl("radiation", term),
        !grepl("development", term),
        !grepl("to heat", term),
        !grepl("response", term), 
        !grepl("organization", term),
        !grepl("assembly", term),
        !grepl("migration", term))
    
    select_GOBP_list <- select_GOBP_list[select_go_terms$id]
    
    
    rel_kegg_terms <- k_path %>%
      tolower() %>%
      grep("virus", x = ., invert = TRUE, value = TRUE) %>%
      grep("viral", x = ., invert = TRUE, value = TRUE) %>%
      grep("addiction", x = ., invert = TRUE, value = TRUE) %>%
      grep("metabol", x = ., invert = TRUE, value = TRUE) %>%
      grep("myopathy", x = ., invert = TRUE, value = TRUE) %>%
      grep("multiple species", x = ., invert = TRUE, value = TRUE)
   
    rel_kegg_terms <- rel_kegg_terms[
      grepl("signaling", rel_kegg_terms) | 
        grepl("differentiation", rel_kegg_terms) |
        grepl("proteolysis", rel_kegg_terms) |
        grepl("ptosis", rel_kegg_terms) |
        grepl("micrornas", rel_kegg_terms) |
        grepl("some", rel_kegg_terms) |
        grepl("cycle", rel_kegg_terms)]
    
    rel_kegg_terms <- names(rel_kegg_terms)

    # Import GOI report data and environment
    goi_analysis <- read.csv(
        file.path(
          outputDir, 
          grep("_cart19_goi_data.csv", list.files(outputDir), value = TRUE)
        )
      ) %>%
      dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name)) 

    # GOI potential genes and analysis ----   
    potential_genes <- apply(
      as.matrix(goi_analysis[
        ,c("Depletion", "Enrichment", "Abundance", "Longitudinal", "Cluster")]), 
      2, function(x){
             goi_analysis$Gene_Name[x]
           })
    
    composite_genes <- unique(unlist(
      potential_genes[c("Enrichment", "Abundance", "Longitudinal", "Cluster")]
    ))

    criteria_order <- c(
      "Depletion", "Enrichment", "Abundance", "Longitudinal", "Cluster"
    )
    
    composite_go <- fisher_hyper_GO_test(
      gene_list = composite_genes, GO_list = select_GOBP_list, odds = FALSE, 
      p_adjust = "BH", lower_tail = FALSE, filter = TRUE, cores = numCores)
    
    select_GOBP_list <- select_GOBP_list[composite_go$GO_ID]
    
    composite_kegg <- fisher_hyper_KEGG_test(
      gene_list = composite_genes, KEGG_list = k_pathList[rel_kegg_terms], 
      odds = FALSE, p_adjust = "BH", lower_tail = FALSE, filter = FALSE, 
      cores = numCores)

    go_term <- lapply(potential_genes, function(x){
      fisher_hyper_GO_test(
        x, select_GOBP_list, odds = FALSE, 
        p_adjust = 'BH', lower_tail = FALSE, cutoff = 1) 
      })
    
    kegg_term <- lapply(potential_genes, function(x){
      fisher_hyper_KEGG_test(
        x, k_pathList[rel_kegg_terms], odds = FALSE, 
        p_adjust = 'BH', lower_tail = FALSE, cutoff = 1)
    })

    go_list_df <- bind_rows(go_term, .id = "Criteria") %>%
      dplyr::select(Criteria, GO_ID, GO_Term, overlap_size, adj.p.value)
    
    kegg_list_df <- bind_rows(kegg_term, .id = "Criteria") %>%
      dplyr::select(Criteria, path_id, KEGG_Term, overlap_size, adj.p.value)

    go_matrix <- sapply(potential_genes, function(x){
     sapply(select_GOBP_list, function(y){ sum(x %in% y) / length(y) }) })
    
    go_matrix <- go_matrix[composite_go$GO_ID,]
        
    kegg_matrix <- sapply(potential_genes, function(x){
     sapply(k_pathList, function(y){ sum(x %in% y) / length(y) }) })
    
    kegg_matrix <- kegg_matrix[composite_kegg$path_id,]
    
    # top x terms
    top_go_terms <- rownames(go_matrix)[seq_len(num_terms)]
    top_kegg_terms <- rownames(kegg_matrix)[seq_len(num_terms)]
    
    top_go_df <- data.frame(
        term = top_go_terms,
        size = lengths(select_GOBP_list[top_go_terms]),
        ovlp = sapply(select_GOBP_list[top_go_terms], function(x){
          sum(composite_genes %in% x) }), 
        adj.p.value = composite_go$adj.p.value[match(
          top_go_terms, composite_go$GO_ID)],
        clus = as.vector(cluster_by_list_similarity(
          keys = top_go_terms, keyList = select_GOBP_list[top_go_terms]))) %>%
      dplyr::arrange(clus, desc(ovlp), adj.p.value)
    
    top_kegg_df <- data.frame(
        term = top_kegg_terms,
        size = lengths(k_pathList[top_kegg_terms]),
        ovlp = sapply(k_pathList[top_kegg_terms], function(x){
          sum(composite_genes %in% x) }), 
        adj.p.value = composite_kegg$adj.p.value[match(
          top_kegg_terms, composite_kegg$path_id)],
        clus = as.vector(cluster_by_list_similarity(
          keys = top_kegg_terms, keyList = k_pathList[top_kegg_terms]))) %>%
      dplyr::arrange(clus, desc(ovlp), adj.p.value)
    
    go_heatmap_data <- as.data.frame(go_matrix[top_go_df$term,]) %>%
      dplyr::mutate(
        GO_ID = row.names(.),
        GO_Term = go_list_df$GO_Term[match(GO_ID, go_list_df$GO_ID)],
        f_GO_term = stringr::str_extract(GO_Term, "[\\w\\s-,]{40}"),
        f_GO_term = ifelse(is.na(f_GO_term), GO_Term, paste0(f_GO_term, "...")),
        f_GO_term = factor(f_GO_term, levels = rev(unique(f_GO_term)))) %>%
      tidyr::gather(
        key = "Criteria", value = "Proportion", 
        -GO_ID, -GO_Term, -f_GO_term) %>%
      left_join(
        dplyr::select(go_list_df, -GO_Term), 
        by = c("GO_ID", "Criteria")) %>%
      dplyr::mutate(
        Proportion = ifelse(Proportion == 0, NA, Proportion),
        Criteria = factor(Criteria, levels = criteria_order),
        Sig = ifelse(
          !is.na(adj.p.value), ifelse(adj.p.value <= 0.05, "*", " "), " ")) %>%
      dplyr::mutate(section = ifelse(Criteria == "Depletion", 1, 2))
    
    kegg_heatmap_data <- as.data.frame(kegg_matrix[top_kegg_df$term,]) %>%
      dplyr::mutate(
        path_id = row.names(.),
        KEGG_Term = kegg_list_df$KEGG_Term[
          match(path_id, kegg_list_df$path_id)],
        KEGG_Term = stringr::str_remove(
          KEGG_Term, fixed(" - Homo sapiens (human)")),
        f_KEGG_term = stringr::str_extract(KEGG_Term, "[\\w\\s-,]{40}"),
        f_KEGG_term = ifelse(
          is.na(f_KEGG_term), KEGG_Term, paste0(f_KEGG_term, "...")),
        f_KEGG_term = factor(
          f_KEGG_term, levels = rev(unique(f_KEGG_term)))) %>%
      tidyr::gather(
        key = "Criteria", value = "Proportion", 
        -path_id, -KEGG_Term, -f_KEGG_term) %>%
      left_join(
        dplyr::select(kegg_list_df, -KEGG_Term), 
        by = c("path_id", "Criteria")) %>%
      dplyr::mutate(
        Proportion = ifelse(Proportion == 0, NA, Proportion),
        Criteria = factor(Criteria, levels = criteria_order),
        Sig = ifelse(
          !is.na(adj.p.value), ifelse(adj.p.value <= 0.05, "*", " "), " ")) %>%
      dplyr::mutate(section = ifelse(Criteria == "Depletion", 1, 2))

    go_heatmap <- go_heatmap_data %>%
        ggplot(aes(x = Criteria, y = f_GO_term)) +
        geom_tile(aes(fill = Proportion)) +
        geom_text(aes(label = Sig)) +
        facet_grid(. ~ section, scales = "free", space = "free") +  
        scale_fill_distiller(
          type = "seq", palette = "Blues", direction = 1, na.value = "white",
          breaks = c(0, 0.05, 0.1)) +
        scale_y_discrete(position = "right") +
        scale_x_discrete(position = "top") + 
        labs(y = NULL, fill = "Term Proportion") +
        guides(fill = guide_colorbar(
          title.position = "top", label.position = "bottom")) +
        theme(
          panel.background = element_blank(),
          axis.text.x.top = element_text(angle = 90, vjust = 0.5, hjust = 0),
          legend.position = "bottom",
          axis.title = element_text(color = "black", face = "bold"),
          legend.title = element_text(color = "black", face = "bold"),
          axis.text = element_text(color = "black"),
          strip.placement = "outside",
          strip.background = element_blank(),
          strip.text = element_blank(),
          aspect.ratio = length(unique(go_heatmap_data$GO_ID)) /
            nrow(dplyr::distinct(go_heatmap_data, Criteria)))
    
      kegg_heatmap <- kegg_heatmap_data %>%
        ggplot(aes(x = Criteria, y = f_KEGG_term)) +
        geom_tile(aes(fill = Proportion)) +
        geom_text(aes(label = Sig)) +
        facet_grid(. ~ section, scales = "free", space = "free") +  
        scale_fill_distiller(
          type = "seq", palette = "Greens", direction = 1, na.value = "white",
          breaks = c(0, 0.05, 0.1)) +
        scale_y_discrete(position = "right") +
        scale_x_discrete(position = "top") + 
        labs(y = NULL, fill = "Term Proportion") +
        guides(fill = guide_colorbar(
          title.position = "top", label.position = "bottom")) +
        theme(
          panel.background = element_blank(),
          axis.text.x.top = element_text(angle = 90, vjust = 0.5, hjust = 0),
          legend.position = "bottom",
          axis.title = element_text(color = "black", face = "bold"),
          legend.title = element_text(color = "black", face = "bold"),
          axis.text = element_text(color = "black"),
          strip.placement = "outside",
          strip.background = element_blank(),
          strip.text = element_blank(),
          aspect.ratio = length(unique(kegg_heatmap_data$path_id)) /
            nrow(dplyr::distinct(kegg_heatmap_data, Criteria)))
      
  }
)

grid.arrange(
  grobs = list(
    go_kegg_heatmaps$go_heatmap, 
    go_kegg_heatmaps$kegg_heatmap), 
  nrow = 1)
```
Figure 3AB. A and B) Heatmaps indicating the proportion of each gene ontology (GO, blue) term or KEGG pathway (green) term are represented by the darker shades. Astericks indicate significant enrichment for the term over random.

\newpage
## Figure 4. Genomic and Epigenetic features associated with vector integration. 
```{r generate_heatmap_data, eval=FALSE}
heatmap_data <- within(
  list(), {
    # Select TDN and Patient sites (d28) for heatmap
    # additionally split by responders and non-responders
    std_data <- bind_rows(list(
        "TDN" = as.data.frame(tdn_sites, row.names = NULL), 
        "D28" = as.data.frame(timepoint_sites, row.names = NULL)),
        .id = "type") %>%
      dplyr::select(type, patient, celltype, timepoint, specimen, posid) %>%
      dplyr::filter(type == "D28" & timepoint == "d28" | type == "TDN") %>%
      left_join(patient_data, by = "patient") %>%
      dplyr::mutate(
        seqnames = str_extract(posid, "[\\w]+"),
        strand = str_extract(posid, "[+-]"),
        pos = as.numeric(str_extract(posid, "[0-9]+$")),
        setname = paste0(type, " - ", determinant_response)) %>%
      dplyr::select(seqnames, strand, pos, setname, posid) %>% 
      dplyr::filter(seqnames %in% c(paste0("chr", 1:22), "chrX", "chrY")) %>%
      as.data.frame()
    
    std_data <- split(std_data, std_data$setname)
    std_heatmap_data <- bind_rows(lapply(std_data, function(df){
        if(nrow(df) < 5000){
          return(df)
        }else{
          idx <- sample(
            seq_len(nrow(df)), 5000, replace = FALSE)
          return(df[idx,])
        }})) %>%
      dplyr::mutate(sampleName = setname, position = pos, refGenome = "hg38") %>%
      dplyr::select(seqnames, strand, position, sampleName, refGenome)

    std_heatmap_sample_info <- std_heatmap_data %>%
      dplyr::group_by(sampleName) %>%
      dplyr::summarise(
        GTSP = unique(sampleName), 
        patient = "Mock") %>%
      dplyr::ungroup() 

    write.csv(
      std_heatmap_data, 
      file.path(outputDir, "manuscript_std_heatmap_sites.csv"), 
      row.names = FALSE, quote = FALSE)
    
    write.csv(
      std_heatmap_sample_info, 
      file.path(outputDir, "manuscript_std_heatmap_samples.csv"), 
      row.names = FALSE, quote = FALSE)
})
```

```{r fig4ABC, fig.width=9, fig.height=6}
# system call: /home/opt/R-3.4.0/bin/Rscript ~/dev/scripts/genomicHeatmapMaker/genomic_heatmap_from_file.R manuscript_std_heatmap_samples.csv -f manuscript_std_heatmap_sites.csv -o manuscript_genomic_std_heatmap -r hg38 -c ~/INSPIIRED/INSPIIRED.yml

gen_heatmap <- within(
  list(), {
    heatmap_sample_info <- read.csv(
      file.path(outputDir, "manuscript_std_heatmap_samples.csv"))
    gen_heatmap <- readRDS(
      file.path(outputDir, "manuscript_genomic_std_heatmap/roc.res.rds"))

    heatmap_scale <- seq(0.2, 0.8, 0.1)
    gen_heatmap_colors <- colorspace::diverge_hsv(
      length(heatmap_scale), h = c(240, 0), v = 1, power = 1)

    select_gen_features <- row.names(gen_heatmap$ROC)
    select_gen_features <- c(
      "boundary.dist", "start.dist", "general.width", "gene.width", 
      "within_refSeq_gene", "refSeq_counts.10k", "refSeq_counts.100k", 
      "refSeq_counts.1M", "GC.100", "GC.1k", "GC.10k", "GC.100k", "GC.1M", 
      "CpG_counts.1k", "CpG_counts.10k", "CpG_density.10k", "CpG_density.100k", 
      "CpG_density.1M", "DNaseI_count.1k", "DNaseI_count.10k", 
      "DNaseI_count.100k", "DNaseI_count.1M")
    
    preffered_gen_names <- c(
      "boundary.dist" = "distance to boundary", 
      "start.dist" = "distance to start", 
      "general.width" = "intergenic width", 
      "gene.width" = "gene width", 
      "within_refSeq_gene" = "in gene, RefSeq", 
      "refSeq_counts.10k" = "RefSeq 10kb", 
      "refSeq_counts.100k" = "RefSeq 100kb", 
      "refSeq_counts.1M" = "RefSeq 1Mb", 
      "GC.100" = "gc.100bp", 
      "GC.1k" = "gc.1kb", 
      "GC.10k" = "gc.10kb", 
      "GC.100k" = "gc.100kb", 
      "GC.1M" = "gc.1Mb", 
      "CpG_counts.1k" = "cpg.< 1kb", 
      "CpG_counts.10k" = "cpg.< 10kb", 
      "CpG_density.10k" = "cpg.Density 10kb", 
      "CpG_density.100k" = "cpg.Density 100kb", 
      "CpG_density.1M" = "cpg.Density 1Mb", 
      "DNaseI_count.1k" = "dnase.< 1kb", 
      "DNaseI_count.10k" = "dnase.< 10kb", 
      "DNaseI_count.100k" = "dnase.< 100kb", 
      "DNaseI_count.1M" = "dnase.< 1Mb")

    gen_heatmap$ROC <- gen_heatmap$ROC[select_gen_features,]

    heatmap_sample_levels <- c(
      "TDN - CR_PRtd", "TDN - PR_NR", "D28 - CR_PRtd", "D28 - PR_NR")
    heatmap_figure_labels <- gsub("_", "/", heatmap_sample_levels)

    stat_cuts <- c(0, 0.001, 0.01, 0.05, 1)
    gen_comp_tdn_stats <- structure(cut(
        gen_heatmap$pvalues$op[select_gen_features, 6], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE),
      names = select_gen_features)
    gen_comp_d28_stats <- structure(cut(
        gen_heatmap$pvalues$op[select_gen_features, 1], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE),
      names = select_gen_features)
    gen_comp_stats <- structure(
      paste0(gen_comp_tdn_stats, "|", gen_comp_d28_stats),
      names = names(gen_comp_tdn_stats))
    gen_row_names <- paste0(
      preffered_gen_names[names(gen_comp_stats)], " - ", gen_comp_stats)

    plot_data <- gen_heatmap$ROC %>%
      reshape2::melt() %>% 
      dplyr::mutate(
        feat = preffered_gen_names[Var1],
        comp.sym = gen_comp_stats[Var1],
        Var1 = paste0(preffered_gen_names[Var1], " - ", comp.sym),
        Var1 = factor(Var1, levels = gen_row_names), 
        Var2 = factor(Var2, levels = heatmap_sample_levels),
        grp = " ",
        sig = as.vector(gen_heatmap$pvalues$np[select_gen_features,]),
        sym = cut(
          sig, stat_cuts, labels = c("***", " **", " * ", "   "), 
          include.lowest = TRUE))
    levels(plot_data$Var2) <- heatmap_figure_labels

    gen_plot <- ggplot(plot_data, aes(x = Var2, y = Var1, fill = value)) + 
      geom_tile(color = 'black') +
      geom_text(aes(label = sym), color = "black", size = 2, nudge_y = -0.15) + 
      scale_x_discrete(position = "top") +
      scale_fill_gradient2(
        breaks = c(0.2, 0.4, 0.6, 0.8), 
        low = gen_heatmap_colors[1], 
        mid = gen_heatmap_colors[round(length(heatmap_scale)/2)], 
        high = gen_heatmap_colors[length(heatmap_scale)], 
        midpoint = 0.5) +
      guides(fill = guide_colorbar(
        title.position = "left", title.hjust = 0.5, 
        direction = "horizontal")) +
      labs(x = NULL, y = NULL, fill = "ROC\nScore") +
      custom_theme + 
      theme(
        legend.position = "bottom",
        axis.text.x.top = element_text(
          angle = 90, hjust = 0, vjust = 0.5, size = 8),
        strip.placement = "outside",
        axis.line = element_blank(),
        axis.ticks.y = element_blank(),
        aspect.ratio = nrow(gen_heatmap$ROC)/ncol(gen_heatmap$ROC))
})

# system call: /home/opt/R-3.4.0/bin/Rscript ~/dev/scripts/EpigeneticHeatmapMaker/epi_heatmap_from_file.R manuscript_std_heatmap_samples.csv -f manuscript_std_heatmap_sites.csv -t ~/dev/scripts/EpigeneticHeatmapMaker/CD4_epi_types.txt -o manuscript_epi_std_heatmap -c ~/INSPIIRED/INSPIIRED.yml

epi_heatmap <- within(
  list(), {
    heatmap_sample_info <- read.csv(
      file.path(outputDir, "manuscript_std_heatmap_samples.csv"))
    epi_heatmap <- readRDS(
      file.path(outputDir, "manuscript_epi_std_heatmap/roc.res.rds"))

    heatmap_scale <- seq(0.2, 0.8, 0.1)
    epi_heatmap_colors <- colorspace::diverge_hsv(
      length(heatmap_scale), h = c(240,120), v = 1, power = 1)

    select_epi_features <- c(
      "CTCF.10Kb", "H2AK5ac.10Kb", "H2AK9ac.10Kb", "H2AZ.10Kb", "H2BK5ac.10Kb", 
      "H2BK5me1.10Kb", "H2BK12ac.10Kb", "H2BK20ac.10Kb", "H2BK120ac.10Kb",   
      "H3K4ac.10Kb", "H3K4me1.10Kb", "H3K4me2.10Kb", "H3K4me3.10Kb",
      "H3K9ac.10Kb", "H3K9me1.10Kb", "H3K9me2.10Kb", "H3K9me3.10Kb",
      "H3K14ac.10Kb", "H3K18ac.10Kb", "H3K23ac.10Kb", "H3K27ac.10Kb", 
      "H3K27me1.10Kb", "H3K27me2.10Kb", "H3K27me3.10Kb", "H3K36ac.10Kb", 
      "H3K36me1.10Kb", "H3K36me3.10Kb", "H3K79me1.10Kb", "H3K79me2.10Kb", 
      "H3K79me3.10Kb", "H3R2me1.10Kb", "H3R2me2.10Kb", "H4K5ac.10Kb", 
      "H4K8ac.10Kb","H4K12ac.10Kb", "H4K16ac.10Kb", "H4K20me1.10Kb", 
      "H4K20me3.10Kb", "H4K91ac.10Kb", "H4R3me2.10Kb", "NRSF.10Kb", 
      "PolII.10Kb")

    epi_heatmap$ROC <- epi_heatmap$ROC[select_epi_features,]

    preffered_epi_names <- structure(
      gsub(".10Kb", "", select_epi_features),
      names = select_epi_features)
    
    heatmap_sample_levels <- c(
      "TDN - CR_PRtd", "TDN - PR_NR", "D28 - CR_PRtd", "D28 - PR_NR")
    heatmap_figure_labels <- gsub("_", "/", heatmap_sample_levels)

    stat_cuts <- c(0, 0.001, 0.01, 0.05, 1)
    epi_comp_tdn_stats <- structure(cut(
        epi_heatmap$pvalues$op[select_epi_features, 6], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE),
      names = select_epi_features)
    epi_comp_d28_stats <- structure(cut(
        epi_heatmap$pvalues$op[select_epi_features, 1], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE),
      names = select_epi_features)
    epi_comp_stats <- structure(
      paste0(epi_comp_tdn_stats, "|", epi_comp_d28_stats),
      names = names(epi_comp_tdn_stats))
    epi_row_names <- paste0(
      preffered_epi_names[names(epi_comp_tdn_stats)], " - ", epi_comp_stats)

    plot_data <- epi_heatmap$ROC %>%
      reshape2::melt() %>% 
      dplyr::mutate(
        feat = preffered_epi_names[Var1],
        comp.sym = epi_comp_stats[Var1],
        grp = ifelse(as.integer(Var1) <= length(levels(Var1))/2, " ", "  "),    
        Var1 = paste0(preffered_epi_names[Var1], " - ", comp.sym),
        Var1 = factor(Var1, levels = rev(epi_row_names)), 
        Var2 = factor(Var2, levels = heatmap_sample_levels),
        sig = as.vector(epi_heatmap$pvalues$np[select_epi_features,]),
        sym = cut(
          sig, 
          stat_cuts, 
          labels = c("***", " **", " * ", "   "), 
          include.lowest = TRUE))
    levels(plot_data$Var2) <- heatmap_figure_labels

    epi_plot <- ggplot(plot_data, aes(x = Var2, y = Var1, fill = value)) + 
      geom_tile(color = 'black') +
      geom_text(aes(label = sym), color = "black", size = 2, nudge_y = -0.15) + 
      facet_wrap(~ grp, scales = "free") + 
      scale_x_discrete(position = "top") +
      scale_fill_gradient2(
        breaks = c(0.2, 0.4, 0.6, 0.8), 
        low = epi_heatmap_colors[1], 
        mid = epi_heatmap_colors[round(length(heatmap_scale)/2)], 
        high = epi_heatmap_colors[length(heatmap_scale)], 
        midpoint = 0.5) +
      guides(fill = guide_colorbar(
        title.position = "left", title.hjust = 0.5, 
        direction = "horizontal")) +
      labs(x = NULL, y = NULL, fill = "ROC\nScore") +
      custom_theme +
      theme(
        legend.position = "bottom",
        axis.text.x.top = element_text(
          angle = 90, hjust = 0, vjust = 0.5, size = 8),
        strip.background = element_rect(fill = "white", color = "white"),
        strip.placement = "outside",
        axis.line = element_blank(),
        axis.ticks.y = element_blank(),
        aspect.ratio = nrow(epi_heatmap$ROC)/(2*ncol(epi_heatmap$ROC)))
})

grid.arrange(
  grobs = list(gen_heatmap$gen_plot, epi_heatmap$epi_plot), 
  layout_matrix = matrix(c(1,1,1,2,2,2,2,2,2), nrow = 1))
```
Figure 4ABC. A) Genomic features and (B and C) Epigenetic features associated with vector integration sites from transduction products and day 28 peripherial blood samples. Associations are calculated by an ROC area method. Values of the ROC area can vary between 0 (negatively associated) and 1 (positively associated), with 0.5 indicating no association. Numbers on the left of A indicated the lengths of genomic regions used to assess the genomic feature. All epigenetic features where assessed within a 10 kb window. Asterisks within the heatmap (on top of colors) indicate a significant difference compared to random, while asterisks beside the heatmap indicate comparisons between clinical response groups (TDN on left and Day 28 on right). P-values indications: p-value < 0.05 (\*), < 0.01 (\*\*), < 0.001 (\*\*\*).

```{r pop_summary}
specimen_population_summary <- within(
  list(), {
    # Specimen summary metrics
    specimen_summary <- summaries$specimen %>%
      dplyr::mutate(determinant_response = patient_data$determinant_response[
        match(patient, patient_data$patient)])
    
    # Plot and compare chao1 distributions between timepoint and response
    chao1_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, Chao1, disease, determinant_response) %>%
      dplyr::mutate(
        determinant_response = gsub(
          "_", "/", as.character(determinant_response)),
        determinant_response = factor(
          determinant_response, levels = c("CR/PRtd", "PR/NR"))) %>%
      dplyr::filter(
        #disease == "CLL",
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")) %>%
      dplyr::mutate(
        Chao1 = log(Chao1, base = 10),
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28")))
      
    chao1_plot <- ggplot(chao1_plot_data, aes(x = timepoint, y = Chao1)) +
      stat_summary(
        mapping = aes(group = timepoint), fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = c(0:5)) +
      facet_wrap(~ determinant_response, scales = "fixed", nrow = 1) + 
      labs(y = "Estimated Clones - Log(Chao1)", x = NULL) +
      custom_theme +
      theme(
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        strip.text = element_text(face = "plain", size = 12),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))
    
    chao1_sig <- split(
      chao1_plot_data$Chao1, 
      paste0(
        chao1_plot_data$determinant_response, " - ", chao1_plot_data$timepoint))
    
    chao1_sig <- as.data.frame(
        matrix(names(chao1_sig)[
          t(combn(seq_along(chao1_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(chao1_sig), 2, function(i){
          wilcox.test(x = chao1_sig[[i[1]]], y = chao1_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      tidyr::separate(V1, into = c("response1", "timepoint1"), sep = " - ") %>%
      tidyr::separate(V2, into = c("response2", "timepoint2"), sep = " - ") %>%
      dplyr::filter(
        ifelse(
          response1 == response2, 
          timepoint1 != timepoint2, timepoint1 == timepoint2)) %>%
      dplyr::mutate(
        p.adj = p.adjust(p.val, method = "BH"),
        p.rnd = round(p.adj, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
    
    # Plot and compare pct_in_txn between timepoint and response
    pct_txn_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, pctTxnUnit, 
        pctNearTxnUn, disease, determinant_response) %>%
      dplyr::filter(
        disease == "CLL",
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")) %>%
      dplyr::mutate(
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28")))
      
    pct_txn_plot <- ggplot(
        pct_txn_plot_data, aes(x = timepoint, y = pctTxnUnit)) +
      stat_summary(
        mapping = aes(group = timepoint), fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = pretty_breaks()) +
      facet_wrap(~ determinant_response, scales = "fixed", nrow = 1) + 
      labs(y = "Percent of Integrations within Txn Units", x = NULL) +
      custom_theme
    
    pct_txn_sig <- split(
      pct_txn_plot_data$pctTxnUnit, 
      paste0(
        pct_txn_plot_data$determinant_response, " - ", pct_txn_plot_data$timepoint))
    
    pct_txn_sig <- as.data.frame(
        matrix(names(pct_txn_sig)[
          t(combn(seq_along(pct_txn_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(pct_txn_sig), 2, function(i){
          wilcox.test(x = pct_txn_sig[[i[1]]], y = pct_txn_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      tidyr::separate(V1, into = c("response1", "timepoint1"), sep = " - ") %>%
      tidyr::separate(V2, into = c("response2", "timepoint2"), sep = " - ") %>%
      dplyr::filter(
        ifelse(
          response1 == response2, 
          timepoint1 != timepoint2, timepoint1 == timepoint2)) %>%
      dplyr::mutate(
        p.adj = p.adjust(p.val, method = "BH"),
        p.rnd = round(p.adj, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
    
    # Plot and compare pct_in_txn between timepoint and response binned patients
    bin_pct_txn_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, pctTxnUnit, 
        pctNearTxnUn, disease, determinant_response) %>%
      dplyr::filter(
        disease == "CLL",
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")) %>%
      dplyr::mutate(
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28")))
      
    bin_pct_txn_plot <- ggplot(
        bin_pct_txn_plot_data, aes(x = timepoint, y = pctTxnUnit)) +
      stat_summary(
        fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = pretty_breaks()) +
      labs(y = "Percent of Integrations within Txn Units", x = NULL) +
      custom_theme +
      theme(
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        strip.text = element_text(face = "plain", size = 12),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

    bin_pct_txn_sig <- split(
      bin_pct_txn_plot_data$pctTxnUnit, bin_pct_txn_plot_data$timepoint)
    
    bin_pct_txn_sig <- as.data.frame(
        matrix(names(bin_pct_txn_sig)[
          t(combn(seq_along(bin_pct_txn_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(bin_pct_txn_sig), 2, function(i){
          wilcox.test(
            x = bin_pct_txn_sig[[i[1]]], y = bin_pct_txn_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      dplyr::rename("timepoint1" = V1, "timepoint2" = V2) %>%
      dplyr::mutate(
        p.rnd = round(p.val, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
})
```

```{r fig4DE, fig.width=4, fig.height=3}
specimen_population_summary$chao1_plot
pandoc.table(
  specimen_population_summary$chao1_sig, 
  style = "simple", split.table = Inf, digits = 3)
```

Figure 4DE. D) Box plot representation of Chao1 estimated population sizes for responders (CR and PRtd), comparing the transduction product and day 28 samples (PR and NR).  E) Box plot representations of Chao1 estimated population sizes for nonresponders, comparing the transduction products and day 28 samples.

\newpage
## Figure 5. Predicting clinical outcome from integration site data.
```{r model_setup}
model_analysis <- within(
  list(), {
    set.seed(714)

    packs <- c(
      "doMC", "glmnet", "spraphal", "caret", "data.table", 
      "magrittr", "tidyverse")
    packs_loaded <- suppressMessages(
      sapply(packs, require, character.only = TRUE))
    if(!all(packs_loaded)){
      print(
        data.frame(
          "R-Packages" = names(packs_loaded), "Loaded" = packs_loaded), 
        row.names = FALSE)
      stop("Check dependancies.")
    }

    rm(packs, packs_loaded)

    registerDoMC(cores = numCores)

    # Load patient metadata ----
    data_dir <- "~/dev/projects/CART19/cart19_analyses/processed_data"
    ref_data_dir <- "~/data/projects/CART19/Determinants_Transcript"
    working_dir <- "~/dev/projects/CART19/cart19_analyses"

    all_specimen_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::select(
        specimen, celltype, timepoint, patient, disease, response,
        simple_response, general_response, numUniqSites) %>%
      dplyr::mutate(
        disease = factor(disease, levels = c("pALL", "aALL", "CLL")),
        response = factor(response, levels = c(
          "None", "Partial", "Partial\nw TnDz", "Complete", 
          "Complete\nw relapse")),
        simple_response = factor(
          simple_response, levels = c("None", "Partial", "Complete")),
        general_response = factor(
          general_response, levels = c("Non-responder", "Responder")),
        determinant_response = factor(ifelse(
          response %in% c(
            "Complete", "Partial\nw TnDz", "Complete\nw relapse"), 
          "CR_PRtd", "PR_NR")),
        clin_trial = stringr::str_extract(patient, "[0-9]+"))

    specimen_data <- dplyr::filter(
      all_specimen_data, 
      disease == "CLL", clin_trial %in% std_clin_trials)

    patient_tdn_specimens <- dplyr::filter(
      specimen_data, 
      timepoint == "d0", celltype == "Tcells", numUniqSites >= 10)

    patient_d28_specimens <- dplyr::filter(
        specimen_data, 
        timepoint %in% c("d25", "d28"), 
        celltype == "PBL", 
        numUniqSites >= 10) %>%
      dplyr::mutate(timepoint = factor(timepoint, levels = c("d25", "d28"))) %>% 
      dplyr::group_by(patient) %>%
      dplyr::arrange(patient, timepoint) %>%
      dplyr::mutate(id = seq_len(n())) %>%
      top_n(1, 1/id) %>%
      dplyr::ungroup() %>%
      dplyr::select(-id) %>%
      dplyr::arrange(disease, response, patient)
    
    ibru_tdn_specimens <- dplyr::filter(
      all_specimen_data,
      timepoint == "d0", celltype == "Tcells", numUniqSites >= 10, 
        !clin_trial %in% std_clin_trials, !is.na(response))

    # Set plot theme ----
    base_theme <- theme_bw() + 
      theme(
        panel.border = element_blank(), 
        axis.line = element_line(color = "black"), 
        panel.grid = element_blank(), 
        strip.background = element_rect(fill = "white"), 
        strip.text = element_text(face = "bold", color = "black"),
        axis.text = element_text(face = "bold", color = "black"), 
        axis.title = element_text(size = 9, face = "bold", color = "black"), 
      legend.title = element_text(face = "bold", color = "black"),
      legend.position = "bottom")
    theme_set(base_theme)

    # Additional processing functions ----
    # The center_scale() function is useful if you have multiple matrices that 
    # may need to be centered and scaled by a different set of values than 
    # their own. If input is only one matrix, then the input matrix will be
    # centered and scaled to itself. If two matrices are supplied, the second
    # will act as the training matrix and the means and standard deviation from
    # the second matrix will be applied to the first matrix for centering and
    # scaling. Models, like PCA, can be built on scaled data, but if you want to
    # use a model like that on additional data, than the additional data needs 
    # to be scaled in the same manner for accuracy.
    center_scale <- function(input, trn = NULL){
      if(is.null(trn)) trn <- input
      means <- apply(trn, 2, mean)
      stdevs <- apply(trn, 2, sd)
      t(apply(input, 1, function(x) (x - means) / stdevs))
    }
    
    # Method to normalized a numerical vector or matrix to proportions.
    normalize <- function(x){
      stopifnot(is.numeric(x))
      x/sum(x)
    } 
     
    # Calculate the within class variance or scatter matrix, used in LDA
    within_class_scatter_matrix <- function(D, cl){
      cl <- factor(cl, levels = unique(cl))
      Reduce("+", lapply(seq_len(length(unique(cl))), function(k){
        d <- D[as.integer(cl) == k,]
        m <- colMeans(d)
        sc_mat <- d - matrix(rep(m, nrow(d)), nrow = nrow(d), byrow = TRUE)
        t(sc_mat) %*% sc_mat
      }))
    }
    
    # Calculate the between class variance or scatter matrix, used in LDA
    between_class_scatter_matrix <- function(D, cl){
      cl_means <- as.data.frame(D) %>%
        dplyr::mutate(cl = factor(cl, levels = unique(cl))) %>%
        dplyr::arrange(cl) %>%
        dplyr::group_by(cl) %>%
        dplyr::summarise_all(mean) %>%
        dplyr::ungroup() %>%
        dplyr::select(-cl) %>%
        as.matrix()
      
      tot_means <- colMeans(D)
      
      cl_N <- table(factor(cl, levels = unique(cl)))
      
      Reduce("+", lapply(seq_len(length(unique(cl))), function(k){
        k_m <- cl_means[k, , drop = FALSE] - tot_means
        cl_N[k] * (t(k_m) %*% k_m)
      }))
    }

    # Linear Discriminant Analysis (LDA) function for identifying components 
    # that tidyr::separate two or more classes given a dimensional input dataset 
    # (D, matrix) with classifications (cl). Scale will scale the data prior 
    # to analysis, change to FALSE if data has already been scaled. Log 
    # transform the data (log_trans) prior to analysis to analyze the data on 
    # a different scale, associated (base) option to change the base of 
    # the logrithm. 
    lineda <- function(D, cl, scale = TRUE, log_trans = FALSE, base = 10){
      if(log_trans) D <- log(D, base = base)
      if(scale) D <- apply(D, 2, function(x) (x - mean(x)) / sd(x))
      Sw <- within_class_scatter_matrix(D, cl)
      Sb <- between_class_scatter_matrix(D, cl)
      W <- svd( t(solve(Sw)) %*% Sb )
      svo <- order(W$d, decreasing = TRUE)
      Ws <- list()
      Ws$values <- W$d[svo[seq_len(length(unique(cl))-1)]]
      Ws$rotation <- W$u[,svo[seq_len(length(unique(cl))-1)], drop = FALSE]
      Ws$orth_rot <- W$v[,svo[seq_len(length(unique(cl))-1)], drop = FALSE]
      row.names(Ws$rotation) <- row.names(Ws$orth_rot) <- row.names(Sw)
      colnames(Ws$rotation) <- colnames(Ws$orth_rot) <- paste0(
        "LD", seq_len(ncol(Ws$rotation)))
      Ws$explained <- 100 * Ws$values / sum(Ws$values, na.rm = TRUE)
      Y <- D %*% (
        Ws$rotation %*% diag(sqrt(Ws$values), nrow = length(Ws$values)))
      rownames(Y) <- rownames(D)
      colnames(Y) <- colnames(Ws$rotation)
      return(list("trans" = Y, "svd" = Ws))
    }

    # Plot a multivariate analysis, such as PCA or LDA. Only selects the first 
    # two components for plotting. Additionally supply a classification vector
    # (cl) that will color the points differently on the output plot. Output is 
    # a ggplot object and can be further manipulated with the ggplot2 package.
    plot_mva <- function(D, cl){
      stopifnot(ncol(D) >= 2)
      Y <- as.data.frame(D[,1:2]) %>%
        dplyr::mutate("Class" = cl)
      names(Y) <- c("V1", "V2", "Class")
      
      Ym <- Y %>%
        dplyr::group_by(Class) %>%
        dplyr::summarise_all(mean) %>%
        dplyr::ungroup()
      
      Yl <- Y %>%
        dplyr::mutate(
          E1 = Ym$V1[match(Class, Ym$Class)],
          E2 = Ym$V2[match(Class, Ym$Class)])
      
      ggplot() + 
        geom_hline(yintercept = 0, color = "grey70") +
        geom_vline(xintercept = 0, color = "grey70") +
        geom_segment(
          data = Yl, 
          aes(x = V1, xend = E1, y = V2, yend = E2, color = Class)) +
        stat_ellipse(data = Y, aes(x = V1, y = V2, color = Class)) +
        geom_point(
          data = Y, aes(x = V1, y = V2, fill = Class),
          size = 3, color = "white", shape = 21) +
        geom_point(
          data = Ym, aes(x = V1, y = V2, fill = Class),
          size = 5, color = "white", shape = 24) +
        geom_rug(data = Y, aes(x = V1, y = V2, color = Class), sides = "b") +
        scale_color_brewer(type = "qual", palette = "Set1") +
        scale_fill_brewer(type = "qual", palette = "Set1")
    }

    # Plot data in on a Receiver Operator Characteristic curve. The logic vector 
    # should indicate a logical outcome of predicting one classification, 
    # i.e. if two classes exist (A and B), then the logic vector can equal 
    # logic <- class == "A". Data should be a numerical vector ... . Output is 
    # a ggplot object and can be further manipulated with the ggplot2 package.
    plot_roc <- function(logic, data, group = NULL, 
                         ties.method = "average", na.rm = FALSE, rdm.seed = 714){
      stopifnot(is.logical(logic))
      stopifnot(is.numeric(data)) 
      
      if(is.null(group)) group <- rep(1, length(logic))
      
      if(na.rm){
        na_idx <- is.na(data)
        logic <- logic[!na_idx]
        data <- data[!na_idx]
        group <- group[!na_idx]
      }
      
      grps <- structure(unique(group), names = unique(group))
      
      roc_data <- bind_rows(lapply(grps, function(grp){
        set.seed(rdm.seed)
        is_grp <- group == grp
        d <- data[is_grp]
        log <- logic[is_grp]
        x <- d[!log]
        y <- d[log]
        m <- sum(!log)
        n <- sum(log)
        x.ranks <- rank(x, ties.method = ties.method)
        y.ranks <- rank(y, ties.method = ties.method)
        is.x <- rep( c(TRUE,FALSE), c( m, n ))
        xy.ord <- is.x[order( 1/rank(c(x,y), ties.method = ties.method) )]
        xy.mag <- ifelse(xy.ord, 1/m, 1/n)
        data.frame(
          x.mag = c(0, cumsum(ifelse(xy.ord, xy.mag, 0))),
          y.mag = c(0, cumsum(ifelse(xy.ord, 0, xy.mag)))) %>%
          dplyr::group_by(y.mag) %>%
          dplyr::mutate(auc.i = ifelse(
            (max(x.mag) - min(x.mag)) > 0, 
            (max(x.mag) - min(x.mag)) * y.mag / n(), 0)) %>%
          dplyr::ungroup() %>%
          as.data.frame() }), .id = "grp") %>%
        dplyr::mutate(grp = factor(grp, unique(group)))
      
      plot_auc_data <- roc_data %>%
        dplyr::group_by(grp) %>%
        dplyr::summarise(auc = sum(auc.i)) %>%
        dplyr::ungroup() %>% as.data.frame()
      
      # Calculate theta
      theta_data <- bind_rows(lapply(grps, function(grp){
        set.seed(rdm.seed)
        is_grp <- group == grp
        d <- data[is_grp]
        log <- logic[is_grp]
        x <- d[!log]
        y <- d[log]
        m <- sum(!log)
        n <- sum(log)
        x.ranks <- rank(x, ties.method = ties.method)
        y.ranks <- rank(y, ties.method = ties.method)
        is.x <- rep( c(TRUE,FALSE), c( m, n ))
        
        xy.ranks <- split(rank(c(x,y), ties.method = ties.method), is.x)
        V.10 <- 1 - ( (xy.ranks[[2]] - x.ranks) / n )
        V.01 <- (xy.ranks[[1]] - y.ranks) / m 
        theta.hat <- mean(V.10)
        
        # Not sure the varience is calculated right as the 
        # hotROCs:::ROC.DDCP does something a little different with multiple
        # tested variables, maybe a correction for multiple comparisons that
        # isn't included here.
        S.10 <- var(V.10)
        S.01 <- var(V.01)
        S <- S.10/m + S.01/n
        
        res <- data.frame(theta = theta.hat, var = S) }), .id = "grp")
      
      p <- ggplot(roc_data, aes(x = x.mag, y = y.mag)) + 
        geom_abline(slope = 1, intercept = 0, color = "grey50") +
        geom_ribbon(aes(ymin = 0, ymax = y.mag, fill = grp), alpha = 0.1) + 
        geom_line(aes(color = grp)) + 
        scale_color_brewer(type = "qual", palette = "Set1") +
        scale_fill_brewer(type = "qual", palette = "Set1") +
        labs(x = "False Positive Rate", y = "True Positive Rate")
      
      if(length(unique(group)) == 1) p <- p + theme(legend.position = "none")
      if(nrow(plot_auc_data) == 1){
        p <- p + annotate(
          "text", x = 0.7, y = 0.1, size = 2.5,
          label = paste0("ROC.AUC=", round(plot_auc_data$auc, digits = 3)))
      }else{
        pander::pander(plot_auc_data)
      }
      p
    }

    # Plot a glmnet model cross-validation performance. Supply the output of 
    # glmnet::cv.glmnet() and the results will be plotted in a similar fashion 
    # to calling plot on the same object, the output will however be a ggplot
    # object and can be further manipulated by the ggplot2 package.
    plot_lasso <- function(glmnet_model, minOnly = FALSE){
      df <- data.frame(
          glmnet_model[c("lambda", "cvm", "cvsd", "cvup", "cvlo", "nzero")]) %>%
        dplyr::mutate(
          loglambda = log(lambda),
          fit = ifelse(
            lambda < glmnet_model$lambda.min, "over", 
            ifelse(lambda <= glmnet_model$lambda.1se, "optimal", "under")),
          fit = factor(fit, levels = c("over", "optimal", "under")),
          yzero = rep(0.9, n()),
          inc_y = rev(rep(c(TRUE, rep(FALSE, 3)), 50)[seq_len(n())]))
      
      if(minOnly){
        v_seg_x <- log(glmnet_model$lambda.min)
        v_seg_y <- -Inf
        v_seg_yend <- 0.85
        h_seg_x <- log(glmnet_model$lambda.min)
        h_seg_y <- c(glmnet_model$cvm[match(
            glmnet_model$lambda.min, glmnet_model$lambda)])
        h_seg_xend <- c(Inf)
      }else{
        v_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        v_seg_y <- c(-Inf, -Inf)
        v_seg_yend <- c(0.85, 0.85)
        h_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        h_seg_y <- c(glmnet_model$cvm[match(
            c(glmnet_model$lambda.min, glmnet_model$lambda.1se), 
            glmnet_model$lambda)])
        h_seg_xend <- c(Inf, Inf)
      }
      
      ggplot() +
        annotate(
          "segment", x = v_seg_x, y = v_seg_y, 
          xend = v_seg_x, yend = v_seg_yend,
          linetype = "dotted", color = "grey50") +
        annotate(
          "segment", x = h_seg_x, y = h_seg_y, 
          xend = h_seg_xend, yend = h_seg_y,
          linetype = "dotted", color = "grey50") +
        geom_errorbar(
          data = df, 
          aes(x = loglambda, ymin = cvlo, ymax = cvup, color = fit), 
          size = 0.25) +
        geom_point(data = df, aes(x = loglambda, y = cvm, color = fit)) +
        geom_text(
          data = df[df$inc_y,],
          aes(x = loglambda, y = yzero, label = nzero, color = fit), 
          show.legend = FALSE, size = 2.5) +
        scale_color_brewer(palette = "Set1") +
        scale_y_continuous(
          sec.axis = sec_axis(
            trans = ~., breaks = h_seg_y, 
            labels = round(h_seg_y, digits = 2))) +
        labs(
          color = "Model Fit", x = "Ln(Lambda)", y = "Misclassification Error")
    }

    # A modified plot_lasso for manuscript figures.
    plot_lasso_mod <- function(glmnet_model, custom_breaks, minOnly = FALSE){
      df <- data.frame(
          glmnet_model[c("lambda", "cvm", "cvsd", "cvup", "cvlo", "nzero")]) %>%
        dplyr::mutate(
          loglambda = log(lambda),
          fit = ifelse(
            lambda < glmnet_model$lambda.min, "over", 
            ifelse(lambda <= glmnet_model$lambda.1se, "optimal", "under")),
          fit = factor(fit, levels = c("over", "optimal", "under")),
          yzero = rep(0.9, n()),
          inc_y = rev(rep(c(TRUE, rep(FALSE, 3)), 50)[seq_len(n())]),
          ori_n = !rev(duplicated(rev(nzero))),
          mark_n = ori_n & nzero %in% custom_breaks)
      
      break_marks <- dplyr::filter(df, mark_n) %>%
        dplyr::distinct(nzero, loglambda)
      
      if(minOnly){
        v_seg_x <- log(glmnet_model$lambda.min)
        v_seg_y <- -Inf
        v_seg_yend <- 0.85
        h_seg_x <- log(glmnet_model$lambda.min)
        h_seg_y <- c(glmnet_model$cvm[match(
            glmnet_model$lambda.min, glmnet_model$lambda)])
        h_seg_xend <- c(Inf)
      }else{
        v_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        v_seg_y <- c(-Inf, -Inf)
        v_seg_yend <- c(0.85, 0.85)
        h_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        h_seg_y <- c(glmnet_model$cvm[match(
            c(glmnet_model$lambda.min, glmnet_model$lambda.1se), 
            glmnet_model$lambda)])
        h_seg_xend <- c(Inf, Inf)
      }
      
      ggplot() +
        annotate(
          "segment", x = v_seg_x, y = v_seg_y, 
          xend = v_seg_x, yend = v_seg_yend,
          linetype = "dotted", color = "grey50") +
        annotate(
          "segment", x = h_seg_x, y = h_seg_y, 
          xend = h_seg_xend, yend = h_seg_y,
          linetype = "dotted", color = "grey50") +
        geom_errorbar(
          data = df, 
          aes(x = loglambda, ymin = cvlo, ymax = cvup, color = fit), 
          size = 0.25) +
        geom_point(data = df, aes(x = loglambda, y = cvm, color = fit)) +
        scale_color_brewer(palette = "Set1") +
        scale_x_continuous(
          breaks = break_marks$loglambda, labels = break_marks$nzero) +
        scale_y_continuous(
          sec.axis = sec_axis(
            trans = ~., breaks = h_seg_y, 
            labels = round(h_seg_y, digits = 2))) +
        labs(
          color = "Model Fit", 
          x = "Model Complexity\n<-----[please change me to a real arrow ;)]", 
          y = "Misclassification Error")
    }
  }
)
```

```{r model_analysis}
model_analysis <- within(
  model_analysis, {
    
    # Data prep ----
    # Population, genomic, and epigenomic feature summarys of tdn products
    # TDN specimens are defined by celltype == "Tcells", and timepoint == "d0"
    # Additionally, there are sorted samples, but these are not included within 
    # the analysis. For now, we are using all patients (treated for pALL, aALL,
    # and CLL). Further, we are using the designation for patient response as 
    # "Non-Responder" including clinical responses as "None" and "Partial", and 
    # "Responder" including clinical responses as "Partial w TnDz", "Complete", 
    # and "Complete w relapse".

    tdn_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% patient_tdn_specimens$specimen)
    
    d28_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% patient_d28_specimens$specimen)
    
    ibru_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% ibru_tdn_specimens$specimen)
    
    # Data matrix with patients as rownames
    tdn_mat <- as.matrix(
      tdn_data[,(which(names(tdn_data) == "specimen")+1):ncol(tdn_data)])
    rownames(tdn_mat) <- tdn_data$patient
    tdn_mat <- tdn_mat[patient_tdn_specimens$patient,]
    
    d28_mat <- as.matrix(
      d28_data[,(which(names(d28_data) == "specimen")+1):ncol(d28_data)])
    rownames(d28_mat) <- d28_data$patient
    d28_mat <- d28_mat[patient_d28_specimens$patient,]
    
    ibru_mat <- as.matrix(
      ibru_data[,(which(names(ibru_data) == "specimen")+1):ncol(ibru_data)])
    rownames(ibru_mat) <- ibru_data$patient
    ibru_mat <- ibru_mat[ibru_tdn_specimens$patient,]
    
    # Patient and response vectors
    pats_tdn <- patient_tdn_specimens$patient
    resp_tdn <- patient_tdn_specimens$determinant_response
    vars <- colnames(tdn_mat)
    
    pats_d28 <- patient_d28_specimens$patient
    resp_d28 <- patient_d28_specimens$determinant_response

    pats_ibru <- ibru_tdn_specimens$patient
    resp_ibru <- ibru_tdn_specimens$determinant_response

    # Dimensional reduction ----
    # In this portion of the code, the input data for tdn and d28 samples are 
    # dimensionally reduced using PCA. This captures almost all the varibility 
    # of the data into principle components that have nearly zero covariance 
    # with each other. This last point is important for building models as 
    # components with high covarience can either confound the model building 
    # process or lead to the model choosing one while the other is nearly 
    # equally important, making interpretation challenging.
    
    tdn_scaled <- center_scale(tdn_mat)
    tdn_pca <- prcomp(x = tdn_scaled, retx = TRUE, scale. = FALSE)
    tdn_trans <- predict(tdn_pca, tdn_scaled)
    
    d28_scaled <- center_scale(d28_mat)
    d28_pca <- prcomp(x = d28_scaled, retx = TRUE, scale. = FALSE)
    d28_trans <- predict(d28_pca, d28_scaled)

    ibru_scaled <- center_scale(ibru_mat, tdn_mat)
    ibru_trans <- predict(tdn_pca, ibru_scaled)

    # Refine model ----
    # In this block of code, a model is refined / generated from the PCA data. 
    # Depending on the number of components included, the model can refine 
    # itself in different directions. Here a serial method is employed to
    # identify the best model by limiting the principle components of the input
    # data limited, starting with the largest contributor to data variance and 
    # increases by adding subsequent important components. Model evaluation is 
    # based on misclassification error, and is therefore minimized to select the
    # best model. 
    # This step really doesn't directly select the model, rather the number of 
    # PCs that need to be included to construct the best model. The 
    # cross-validation generates models through a leave-one out method and then 
    # bases the misclassification error on classifying the left-out sample. The 
    # cross-validation optimizes the lambda coefficient, or the penalty for 
    # inclusion of additional components, as well as the individual beta 
    # coefficients which weight the components in the general linear model. 
    tdn_pca_cutoff <- data.frame(
        component = 2:ncol(tdn_trans),
        misclass = sapply(2:ncol(tdn_trans), function(cutoff){
          cv <- cv.glmnet(
            x = tdn_trans[, seq_len(cutoff), drop = FALSE], y = resp_tdn, 
            family = "binomial", type.measure = "class", 
            nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE)
          cv$cvm[match(cv$lambda.1se, cv$lambda)]
        })) %>%
      dplyr::filter(misclass == min(misclass)) %>%
      dplyr::filter(component == min(component)) %$%
      component
    
    d28_pca_cutoff <- data.frame(
        component = 2:ncol(d28_trans),
        misclass = sapply(2:ncol(d28_trans), function(cutoff){
          cv <- cv.glmnet(
            x = d28_trans[, seq_len(cutoff), drop = FALSE], y = resp_d28, 
            family = "binomial", type.measure = "class", 
            nfold = nrow(d28_trans), grouped = FALSE, parallel = TRUE)
          cv$cvm[match(cv$lambda.1se, cv$lambda)]
        })) %>%
      dplyr::filter(misclass == min(misclass)) %>%
      dplyr::filter(component == min(component)) %$%
      component


    # Generate LASSO models ----
    # Using the cutoff for components of the original data, below we construct a 
    # lasso regression model on the patients. This method does a leave-one-out 
    # cross validation as well and selects the lease complex but best performing
    # model to classify the input data for clincial response. 

    cv_tdn_pca <- cv.glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = resp_tdn, 
      family = "binomial", alpha = 1, type.measure = "class", 
      nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE, keep = TRUE)
    
    tdn_min_model <- glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = resp_tdn, 
      family = "binomial", alpha = 1, lambda = cv_tdn_pca$lambda.min)
    
    cv_d28_pca <- cv.glmnet(
      x = d28_trans[,seq_len(d28_pca_cutoff)], y = resp_d28, 
      family = "binomial", alpha = 1, type.measure = "class", 
      nfold = nrow(d28_trans), grouped = FALSE, parallel = TRUE, keep = TRUE)
    
    d28_min_model <- glmnet(
      x = d28_trans[,seq_len(d28_pca_cutoff)], y = resp_d28, 
      family = "binomial", alpha = 1, lambda = cv_d28_pca$lambda.min)

    # Feature annotations ----
    all_features <- colnames(tdn_mat)
    format_features <- structure(
      c("unique sites", "Shannon index", 
        "Gini index", "Chao(1) est.", 
        "UC50", "percent in txn. unit", 
        "percent in same orientation", "percent near txn. unit", 
        "percent in onco-related gene", "estimated abundance", 
        "relative abundance", "RefSeq 10kb", 
        "RefSeq 100kb", "RefSeq 1Mb", 
        "gc.100bp", "gc.1kb", "gc.10kb", "gc.100kb", "gc.1Mb", 
        "cpg.< 1kb", "cpg.< 10kb", 
        "cpg.Density 10kb", "cpg.Density 100kb", "cpg.Density 1Mb",
        "dnase.< 1kb", "dnase.< 10kb", 
        "dnase.< 100kb", "dnase.< 1Mb", 
        "Activated CD4+ HDAC6", "Activated CD4+ Tip60", 
        "Activated Nucleosomes", "Brd2 promoters", 
        "Brd3 promoters", "Brd4 promoters", "CTCF", 
        "H2AK5ac", "H2AK9ac", "H2AZ", "H2BK120ac", "H2BK12ac", "H2BK20ac", 
        "H2BK5ac", "H2BK5me1", 
        "H3K14ac", "H3K18ac", "H3K23ac", "H3K27ac", "H3K27me1", "H3K27me2", 
        "H3K27me3", "H3K36ac", "H3K36me1", "H3K36me3", "H3K4ac", "H3K4me1", 
        "H3K4me2", "H3K4me3", "H3K79me1", "H3K79me2", "H3K79me3", "H3K9ac", 
        "H3K9me1", "H3K9me2", "H3K9me3", "H3R2me1", "H3R2me2", "H4K12ac", 
        "H4K16ac", "H4K20me1", "H4K20me3", "H4K5ac", "H4K8ac", "H4K91ac",
        "H4R3me2", "HP1a promoters", "HP1b promoters", 
        "NRSF", "PolII", "Resting CD4+ CBP", "Resting CD4+ HDAC1", 
        "Resting CD4+ HDAC2", "Resting CD4+ HDAC3", "Resting CD4+ HDAC6", 
        "Resting CD4+ MOF", "Resting CD4+ p300", "Resting CD4+ PCAF", 
        "Resting CD4+ Tip60", "Resting Nucleosomes", 
        "clusters represented", "sites in clusters", "abundance in clusters"),
      names = all_features)
    
    grouped_features <- structure(
      c("numUniqSites", "estAbund", "relAbund", "ShannonIndex", "GiniIndex", 
        "Chao1", "UC50", "clustersRepresented", "numSitesInClusters",
        "abundInClusters", "pctTxnUnit", "pctSameOrt", "pctNearTxnUn", 
        "pctInOnco", "refSeq_counts.10k", "refSeq_counts.100k", 
        "refSeq_counts.1M", "GC.100", "GC.1k", "GC.10k", "GC.100k", "GC.1M",
        "CpG_counts.1k", "CpG_counts.10k", "CpG_density.10k", 
        "CpG_density.100k", "CpG_density.1M", "DNaseI_count.1k", 
        "DNaseI_count.10k", "DNaseI_count.100k", "DNaseI_count.1M",
        "H2AK5ac.10k", "H2AK9ac.10k", "H2AZ.10k", "H2BK120ac.10k", 
        "H2BK12ac.10k", "H2BK20ac.10k", "H2BK5ac.10k", "H2BK5me1.10k", 
        "H3K14ac.10k", "H3K18ac.10k", "H3K23ac.10k", "H3K27ac.10k", 
        "H3K27me1.10k", "H3K27me2.10k", "H3K27me3.10k", "H3K36ac.10k", 
        "H3K36me1.10k", "H3K36me3.10k", "H3K4ac.10k", "H3K4me1.10k", 
        "H3K4me2.10k", "H3K4me3.10k", "H3K79me1.10k", "H3K79me2.10k", 
        "H3K79me3.10k", "H3K9ac.10k", "H3K9me1.10k", "H3K9me2.10k",
        "H3K9me3.10k", "H3R2me1.10k", "H3R2me2.10k", "H4K12ac.10k", 
        "H4K16ac.10k", "H4K20me1.10k", "H4K20me3.10k", "H4K5ac.10k", 
        "H4K8ac.10k", "H4K91ac.10k", "H4R3me2.10k", "CTCF.10k", "NRSF.10k",
        "PolII.10k", "Brd2_promoters.10k", "Brd3_promoters.10k", 
        "Brd4_promoters.10k", "HP1a_promoters.10k", "HP1b_promoters.10k", 
        "Act_CD4_HDAC6.10k", "Act_CD4_Tip60.10k", "ActivatedNucleosomes.10k", 
        "RestingNucleosomes.10k", "Rest_CD4_CBP.10k", "Rest_CD4_HDAC1.10k",
        "Rest_CD4_HDAC2.10k", "Rest_CD4_HDAC3.10k", "Rest_CD4_HDAC6.10k",
        "Rest_CD4_MOF.10k", "Rest_CD4_p300.10k", "Rest_CD4_PCAF.10k",
        "Rest_CD4_Tip60.10k"
      ),
      names = c(
        rep("Population", 10), rep("Genomic", 21), 
        rep("Epigenetic", 39), rep("Bound Proteins", 21)
      )
    )

  }
)
```

```{r fig5AB, fig.height=3.5, fig.width=7}
model_analysis <- within(
  model_analysis, {
    # TDN Model cross-validation
    lambda_plot_tdn <- plot_lasso(cv_tdn_pca, minOnly = TRUE) +
      labs(title = "Transduction Product Model") +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    lambda_plot_mod_tdn <- plot_lasso_mod(
        cv_tdn_pca, custom_breaks = c(21, 20, 19, 17, 15, 4), minOnly = TRUE) +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    # D28 Model cross-validation
    lambda_plot_d28 <- plot_lasso(cv_d28_pca, minOnly = TRUE) +
      labs(title = "Day 28 Sample Model") +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    lambda_plot_mod_d28 <- plot_lasso_mod(
        cv_d28_pca, custom_breaks = c(0, 5, 9, 15, 16), minOnly = TRUE) +
      theme(plot.title = element_text(size = 10, face = "bold"))
})

grid.arrange(
  grobs = list(
    model_analysis$lambda_plot_tdn, model_analysis$lambda_plot_d28), 
  nrow = 1)
```
Figure 5AB. A total of 91 features spanning population metrics, genomic, and epigenetic features from 29 patients were used in a least absolute shrinkage and selection operator (LASSO) logistic regression to build a classification model.  Results from leave-one-out cross-validation of models based on A) transduction products and B) day 28 peripherial blood samples. Misclassification error is reduced as models get more accurate, and often more complex (number of variables presented on the x-axis). Error bars indicated standard error and the minimum value of misclassification is indicate on the right of the plots. 

```{r fig5CD, fig.height=6, fig.width=10.25, out.width="80%"}
# Model contributions
model_analysis <- within(
  model_analysis, {
    
    min_pct <- 1.0
    
    wt_pca_cont_tdn <- tdn_pca$rotation 
    coef_lasso_tdn <- coef(tdn_min_model)
    coef_lasso_tdn <- coef_lasso_tdn[2:nrow(coef_lasso_tdn), , drop = FALSE]
    colnames(coef_lasso_tdn) <- "tdn"
    wt_tdn_mod_cont <- 
      wt_pca_cont_tdn[,seq_len(tdn_pca_cutoff)] %*% coef_lasso_tdn
    
    wt_pca_cont_d28 <- d28_pca$rotation 
    coef_lasso_d28 <- coef(d28_min_model)
    coef_lasso_d28 <- coef_lasso_d28[2:nrow(coef_lasso_d28), , drop = FALSE]
    colnames(coef_lasso_d28) <- "d28"
    wt_d28_mod_cont <- 
      wt_pca_cont_d28[,seq_len(d28_pca_cutoff)] %*% coef_lasso_d28
    
    compare_df <- cbind(wt_tdn_mod_cont, wt_d28_mod_cont) %>% as.matrix() %>%
      as.data.frame() %>%
      dplyr::mutate(
        vars = factor(row.names(.), levels = rev(colnames(tdn_mat))),
        tdn_pct = 100 * tdn**2 / sum(tdn**2),
        tdn_pct = ifelse(tdn > 0, tdn_pct, -tdn_pct),
        d28_pct = 100 * d28**2 / sum(d28**2),
        d28_pct = ifelse(d28 > 0, d28_pct, -d28_pct)) %>%
      dplyr::select(vars, tdn_pct, d28_pct) %>%
      dplyr::arrange(vars) %>%
      tidyr::gather("mod", "pct", -vars) %>%
      dplyr::mutate(
        mod = str_remove(mod, "_pct"),
        mod = gsub("tdn", "TDN Product", mod),
        mod = gsub("d28", "Day 28", mod),
        mod = factor(mod, levels = c("TDN Product", "Day 28")),
        pct = -pct,
        effect = ifelse(pct > 0, "pos", "neg"),
        var_grp = names(grouped_features)[match(vars, grouped_features)],
        var_grp = factor(var_grp, levels = unique(names(grouped_features)))) %>%
      dplyr::arrange(mod, var_grp, desc(pct))
    
    tdn_grp_levels <- compare_df %>%
      dplyr::filter(mod == "TDN Product") %>%
      dplyr::arrange(var_grp, desc(pct)) %$%
      unique(as.character(vars))
    
    d28_grp_levels <- compare_df %>%
      dplyr::filter(mod == "Day 28") %>%
      dplyr::arrange(var_grp, desc(pct)) %$%
      unique(as.character(vars))
      
    facet_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        vars = factor(
          format_features[as.character(vars)],
          levels = rev(format_features[tdn_grp_levels]))) %>%
      dplyr::arrange(vars) %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ mod, scales = "free", space = "free") +
      scale_fill_brewer(palette = "Set1", direction = -1) +
      lims(y = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Models\n(Positive towards Response)") +
      theme(
        strip.text.y = element_text(angle = 0),
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9))
    
    #facet_plot
    
    # Extra plots
    tdn_contrib_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(vars = factor(
        format_features[as.character(vars)],
        levels = rev(format_features[tdn_grp_levels]))) %>%
      dplyr::filter(mod == "TDN Product") %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ ., scale = "free", space = "free") +
      scale_y_continuous(limits = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Model\nTransduction Products\n<---     ---->\nPR/NR    CR/PRtd") +
      theme(
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9),
        strip.text.y = element_text(angle = 0))
    
    d28_contrib_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(vars = factor(
        format_features[as.character(vars)],
        levels = rev(format_features[d28_grp_levels]))) %>%
      dplyr::filter(mod == "Day 28") %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ ., scale = "free", space = "free") +
      scale_y_continuous(limits = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Model\nDay 28 Samples\n<---     ---->\nPR/NR    CR/PRtd") +
      theme(
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9),
        strip.text.y = element_text(angle = 0))
})

grid.arrange(
  grobs = list(
    model_analysis$tdn_contrib_plot, model_analysis$d28_contrib_plot),
  nrow = 1)
```
Figure 5CD. Bar plots indicate the contribution of different features or metrics to classification within each model. Positive contribution indicates direct correlation towards positive clinical outcome while negative contributions indicate a direct correlation to negative clinical outcomes. C) Transduction product model and D) day 28 periferial blood model.

\newpage
```{r fig5EFG, fig.height=6, fig.width=4}
gen_express <- within(
  list(), {
    
    patient_tdn_specimens <- model_analysis$patient_tdn_specimens
    
    # Load baseline txn ----
    txn_mock_stim <- data.table::fread(
        input = file.path(
          outputDir, "fraietta_et_al_2018_data", 
          "cart19_transcript_assay_mockstim.csv"
        ), 
        sep = ",", header = TRUE, data.table = FALSE
      ) %>% 
      dplyr::rename("symbol" = Patient_ID)
    
    txn_mock_stim_mat <- as.matrix(txn_mock_stim[,2:ncol(txn_mock_stim)])
    
    rownames(txn_mock_stim_mat) <- alias_arbiter(
      IDs = txn_mock_stim$symbol, RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias, sep = "|", 
      remove_absent_IDs = NULL, quiet = TRUE
    )
    
    txn_mock_stim_mat <- do.call(rbind, lapply(
      split(as.data.frame(txn_mock_stim_mat), rownames(txn_mock_stim_mat)), 
      function(x) apply(x, 2, sum)
    ))
    
    # Load stimulated txn ----
    txn_exp_stim <- data.table::fread(
        input = file.path(
          outputDir, "fraietta_et_al_2018_data", 
          "cart19_transcript_assay_stimulated.csv"
        ), 
        sep = ",", header = TRUE, data.table = FALSE
      ) %>%
      dplyr::rename("symbol" = Patient_ID)
    
    txn_exp_stim_mat <- as.matrix(txn_exp_stim[,2:ncol(txn_exp_stim)])
    
    rownames(txn_exp_stim_mat) <- alias_arbiter(
      IDs = txn_exp_stim$symbol, RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias, sep = "|", 
      remove_absent_IDs = NULL, quiet = TRUE
    )
    
    txn_exp_stim_mat <- do.call(rbind, lapply(
      split(as.data.frame(txn_exp_stim_mat), rownames(txn_exp_stim_mat)), 
      function(x) apply(x, 2, sum)
    ))
    
    # Normalized data to read density (R/K/M) ----
    txn_mock_stim_mat <- apply(
      txn_mock_stim_mat, 2, function(x) (x/1000)/(sum(x)/1E6)
    )
    
    txn_exp_stim_mat <- apply(
      txn_exp_stim_mat, 2, function(x) (x/1000)/(sum(x)/1E6)
    )
    
    keep_genes <- apply(
      cbind(txn_mock_stim_mat, txn_exp_stim_mat), 
      1, function(x) all(x != 0)
    )
    
    txn_mock_stim_mat <- txn_mock_stim_mat[keep_genes,]
    txn_exp_stim_mat <- txn_exp_stim_mat[keep_genes,]
    
    txn_stim_mat <- txn_exp_stim_mat - txn_mock_stim_mat
    
    txn_exp_v_mock <- data.frame(
      symbol = rownames(txn_mock_stim_mat),
      mock = apply(log10(txn_mock_stim_mat), 1, mean),
      exp = apply(log10(txn_exp_stim_mat), 1, mean),
      wilcox = apply(cbind(txn_mock_stim_mat, txn_exp_stim_mat), 1, function(x){
        
        z <- wilcox.test(
          x = x[1:ncol(txn_mock_stim_mat)], 
          y = x[(ncol(txn_mock_stim_mat)+1):(2*ncol(txn_mock_stim_mat))])
        
        z$p.value
        
      }), 
      row.names = NULL
    )
    
    # Select patients and gene data ----
    pats <- dplyr::intersect(std_clin_patients, colnames(txn_exp_stim_mat))
    
    pat_tdn_mat <- tdn_sites %>%
      as.data.frame(row.names = NULL) %>%
      dplyr::filter( patient %in% pats ) %>%
      dplyr::filter( in_gene != FALSE | abs(nearest_geneDist) <= 5000 ) %>%
      dplyr::left_join(patient_data, by = "patient") %>%
      dplyr::select(
        determinant_response, patient, posid, gene_id_wo_annot
      ) %>%
      dplyr::mutate(total_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(determinant_response, patient) %>%
      dplyr::mutate(pat_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(determinant_response) %>%
      dplyr::mutate(grp_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(
        determinant_response, patient, gene_id_wo_annot, 
        total_sites, grp_sites, pat_sites
      ) %>%
      dplyr::summarise(sites = dplyr::n_distinct(patient, posid)) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(pat_pct = sites / pat_sites)
    
    all_tdn_mat <- pat_tdn_mat %>%
      dplyr::group_by(
        determinant_response, gene_id_wo_annot, total_sites, grp_sites
      ) %>%
      dplyr::summarise(sites = sum(sites)) %>%
      dplyr::ungroup() %>%
      tidyr::spread(key = determinant_response, value = sites, fill = 0) %>%
      dplyr::mutate(
        CR_pct = CR_PRtd / grp_sites,
        NR_pct = PR_NR / grp_sites,
        Tot_pct = (CR_PRtd + PR_NR) / total_sites
      ) %>% 
      dplyr::group_by(gene_id_wo_annot) %>%
      dplyr::summarise(
        CR_pct = sum(CR_pct), NR_pct = sum(NR_pct), Tot_pct = sum(Tot_pct)
      ) %>%
      dplyr::ungroup() %>%
      as.data.frame()
    
    row.names(all_tdn_mat) <- all_tdn_mat$gene_id_wo_annot
    
    all_tdn_mat <- as.matrix(all_tdn_mat[,2:ncol(all_tdn_mat)])

    resp <- patient_tdn_specimens$determinant_response[
      match(pats, patient_tdn_specimens$patient)
    ]
    
    genes <- dplyr::intersect(rownames(all_tdn_mat), rownames(txn_exp_stim_mat))
    
    mean_txn_exp_mat <- do.call(cbind, lapply(unique(resp), function(r){
      mat <- txn_exp_stim_mat[, pats %in% pats[resp == r]]
      apply(mat, 1, mean)
    }))
    
    colnames(mean_txn_exp_mat) <- unique(resp)
    mean_txn_exp_mat <- mean_txn_exp_mat[genes,]
    
    stim_txn_mat <- do.call(cbind, lapply(unique(resp), function(r){
      mat <- txn_stim_mat[, pats %in% pats[resp == r]]
      apply(mat, 1, mean)
    }))
    
    colnames(stim_txn_mat) <- unique(resp)
    stim_txn_mat <- stim_txn_mat[genes,]
    
    # Determine Rank orders for gene expression ----
    grp_cnt <- 10
    
    total_gene_txn_order <- apply(mean_txn_exp_mat, 1, mean) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    CR_gene_txn_order <- mean_txn_exp_mat[, "CR_PRtd"] %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    NR_gene_txn_order <- mean_txn_exp_mat[, "PR_NR"] %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    
    stim_gene_txn_order <- apply(stim_txn_mat, 1, mean) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )
    
    diff_gene_txn_order <- apply(stim_txn_mat, 1, diff) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(
        gene = row.names(.)
      ) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )
    
    keep_cnt <- 500
    
    grp_diff_genes <- diff_gene_txn_order %>%
      dplyr::filter(rank_ord <= keep_cnt | rank_ord >= n()-keep_cnt) %>%
      dplyr::mutate(
        preference = ifelse(rank_ord <= keep_cnt, "NR favored", "CR favored")
      ) %$%
      structure(gene, names = preference)
    
    diff_gene_txn_order %>%
      dplyr::filter(gene %in% grp_diff_genes) %>%
      dplyr::mutate(
        preference = factor(
          names(grp_diff_genes)[match(gene, grp_diff_genes)], 
          levels = c("NR favored", "CR favored")
        )
      ) %>%
      dplyr::group_by(preference) %>%
      dplyr::summarise(
        CR_pct = sum(CR_pct),
        NR_pct = sum(NR_pct)
      ) %>%
      dplyr::ungroup() %>%
      tidyr::gather(key = "resp", value = "pct", -preference) %>% 
      ggplot(aes(x = resp, y = pct)) +
      geom_bar(stat = "identity") +
      facet_grid(. ~ preference, scales = "free") +
      custom_theme

    pat_spec_grp_data <- pat_tdn_mat %>%
      dplyr::rename(
        gene = gene_id_wo_annot,
        resp = determinant_response
      ) %>%
      dplyr::filter(gene %in% grp_diff_genes) %>%
      dplyr::mutate(
        preference = factor(
          names(grp_diff_genes)[match(gene, grp_diff_genes)],
          levels = c("NR favored", "CR favored")
        ),
        resp = factor(
          gsub("_", "/", resp), levels = c("PR/NR", "CR/PRtd")
        )
      ) %>%
      dplyr::group_by(resp, patient, preference) %>%
      dplyr::summarise(pct = sum(pat_pct)) %>%
      dplyr::ungroup() %>%
      dplyr::filter(preference == "CR favored")
    
    pat_spec_sig_test <- pat_spec_grp_data %>%
      dplyr::group_by(preference) %>%
      dplyr::summarise(
        sig = wilcox.test(pct ~ resp)$p.value
      )
    
    pct_intsites_by_grp_plot <- ggplot() +
      geom_boxplot(
        data = pat_spec_grp_data, 
        aes(x = resp, y = pct * 100, fill = resp), 
        outlier.alpha = 0
      ) +
      geom_text(
        data = pat_spec_sig_test, 
        aes(
          x = rep(1.5, nrow(pat_spec_sig_test)),
          y = rep(10, nrow(pat_spec_sig_test)),
          label = sprintf("p-value = %.3f", round(sig, digits = 3))
        )
      ) +
      scale_fill_brewer(type = "qual", palette = "Set1") +
      labs(
        x = "Patient Response Groups", 
        y = "Percent of Integration Sites",
        title = "B."
      ) +
      custom_theme + 
      theme(
        legend.position = "none",
        axis.line = element_line(color = "black"),
        axis.text.x = element_text(face = "bold"),
        plot.title = element_text(color = "black", size = 12, face = "bold")
      )
      
    total_gene_exp_plot <- total_gene_txn_order %>%
      dplyr::group_by(rank_grp) %>%
      dplyr::summarise(CR = sum(CR_pct), NR = sum(NR_pct)) %>%
      tidyr::gather(key = "type", value = "pct", -rank_grp) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        type = factor(
          ifelse(type == "CR", "CR/PRtd", "PR/NR"), 
          levels = c("PR/NR", "CR/PRtd")
        )
      ) %>%
      ggplot(aes(x = rank_grp, y = pct * 100, color = type)) +
      geom_point() + 
      geom_line(alpha = 0.25) +
      facet_wrap(type ~ ., ncol = 1, scales = "free_x") +
      scale_x_continuous(breaks = 1:10, labels = 1:10) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        x = "Stimulated Expression Rank Groups", 
        y = "Percent of Integration Sites",
        color = NULL,
        title = "A."
      ) +
      custom_theme + 
      theme(
        legend.position = "none",
        axis.line = element_line(color = "black"),
        plot.title = element_text(color = "black", size = 12, face = "bold")
      )
    
    criteria_palette <- structure(
      colorRampPalette(RColorBrewer::brewer.pal(11, "Spectral"))(
        n = length(unique(goi_data$Criteria))
      ),
      names = sort(unique(goi_data$Criteria))
    )
    
    goi_total_rank_plot <- total_gene_txn_order %>% 
      dplyr::filter(gene %in% unlist(goi_lists)) %>%
      dplyr::arrange(rank_grp) %>%
      dplyr::mutate(
        criteria = goi_data$Criteria[match(gene, goi_data$Gene_Name)],
        rank_grp = factor(rank_grp, levels = unique(rank_grp))
      ) %>%
      ggplot(aes(x = rank_grp)) +
      geom_bar(aes(fill = criteria)) +
      scale_fill_manual(values = criteria_palette) +
      labs(
        x = "Stimulated Expression Rank Groups",
        y = "Gene Count",
        fill = "Criteria"
      ) +
      custom_theme
  
  }
)

grid.arrange(
  grobs = list(
    gen_express$total_gene_exp_plot, gen_express$pct_intsites_by_grp_plot
  ),
  layout_matrix = matrix(c(1,1,1,2,2), ncol = 1)
)

```
Figure 5EGF. ...

\newpage
# Supplemental figures and tables

## Table S1. Patient Information

Written to file: /path/to/CART19_intsite_manuscript_analysis/data/sup_tbl_1_patient_info.csv

```{r pat_table}
patient_sites_data <- all_sites %>%
  as.data.frame(row.names = NULL) %>%
  dplyr::mutate(posid = generate_posid(all_sites)) %>%
  dplyr::group_by(patient, samplename, posid) %>%
  dplyr::summarise(
    reads = sum(count), cells = n()
  ) %>%
  dplyr::group_by(patient) %>%
  dplyr::summarise(
    reads = sum(reads), cells = sum(cells), sites = n_distinct(posid)
  ) %>%
  dplyr::ungroup()

sup_tbl_s1 <- patient_data %>%
  dplyr::select(
    patient, disease, clin_trial, response, determinant_response
    ) %>%
  dplyr::filter(!is.na(response)) %>%
  dplyr::arrange(as.numeric(clin_trial), patient) %>%
  dplyr::mutate(
    determinant_response = gsub("_", "/", determinant_response),
    clin_trial = ifelse(
      clin_trial == "959", "CHP959", paste0("UPCC",clin_trial)
    ),
    response = gsub("\n", " ", response),
    response = gsub("w", "w/", response)
  ) %>%
  dplyr::left_join(patient_sites_data, by = "patient") %>%
  dplyr::rename(
    "Patient ID" = patient, "Disease" = disease, "Clin. Trial" = clin_trial, 
    "Response" = response, "Resp. Class" = determinant_response,
    "Reads" = reads, "Cells Sampled" = cells,
    "Unique Int. Sites" = sites
  )
  
write.csv(
  x = sup_tbl_s1, 
  file = file.path(outputDir, "sup_tbl_1_patient_info.csv"),
  quote = TRUE, 
  row.names = FALSE
)

```

## Table S2. Specimen / Sample Information

Written to file: /path/to/CART19_intsite_manuscript_analysis/data/sup_tbl_2_specimen_info.csv

```{r spec_table}
specimen_sites_data <- all_sites %>%
  as.data.frame(row.names = NULL) %>%
  dplyr::mutate(posid = generate_posid(all_sites)) %>%
  dplyr::group_by(specimen, samplename, posid) %>%
  dplyr::summarise(
    reads = sum(count), cells = n()
  ) %>%
  dplyr::group_by(specimen) %>%
  dplyr::summarise(
    reads = sum(reads), cells = sum(cells), sites = n_distinct(posid)
  ) %>%
  dplyr::ungroup()

sup_tbl_s2 <- summaries$specimen %>%
  dplyr::select(specimen, patient, celltype, timepoint) %>%
  dplyr::filter(patient %in% sup_tbl_s1$`Patient ID`) %>%
  dplyr::arrange(specimen) %>%
  left_join(specimen_sites_data, by = "specimen") %>%
  dplyr::mutate(
    clin_trial = stringr::str_extract(patient, "[0-9]+"),
    clin_trial = ifelse(
      clin_trial == "959", "CHP959", paste0("UPCC", clin_trial))
  ) %>%
  dplyr::select(
    specimen, patient, clin_trial, celltype, 
    timepoint, reads, cells, sites
  ) %>%
  dplyr::rename(
    "GTSP ID" = specimen, "Patient ID" = patient, 
    "Clin. Trial" = clin_trial, "Cell Type" = celltype, 
    "Time Point" = timepoint, "Reads" = reads, "Cells Sampled" = cells,
    "Unique Int. Sites" = sites
  )
  
write.csv(
  x = sup_tbl_s2, 
  file = file.path(outputDir, "sup_tbl_2_specimen_info.csv"),
  quote = TRUE, 
  row.names = FALSE
)

```

```{r additional_calcs, eval=FALSE}
## Comparision to Shifrut et al. 2018

shifrut_comparison <- within(
  list(), {
    
    # Check the overlap between the top genes identified from positive and 
    # negative effectors to T-cell growth.

    #gene_limit <- 25
    
    ## Supporting data from Shifrut et. al. 2018
    shifrut_gw_screen <- data.table::fread(
      paste0("zcat ", file.path(utilsDir, "gw_SLICE_exp_data.csv.gz")),
      data.table = FALSE
    )
    
    shifrut_rep_screen <- data.table::fread(
      paste0("zcat ", file.path(utilsDir, "rep_SLICE_exp_data.csv.gz")),
      data.table = FALSE
    )

    # Make sure the gene names are consistent across datasets
    shifrut_screen_genes <- alias_arbiter(
      IDs = unique(shifrut_rep_screen$id), 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    total_overlapping_genes <- intersect(
      gene_impact$gene_name, shifrut_screen_genes
    )

    ### Identify reproducible negatively associated genes
    shifrut_neg_genes <- dplyr::arrange(
        shifrut_rep_screen, `neg|fdr`, `neg|score`
      ) %>%
      dplyr::filter(`neg|fdr` <= 0.05)
    
    shifrut_neg_genes <- alias_arbiter(
      IDs = shifrut_neg_genes$id, 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    ### Identify reproducible positively associated genes
    shifrut_pos_genes <- dplyr::arrange(
        shifrut_rep_screen, `pos|fdr`, `pos|score`
      ) %>%
      dplyr::filter(`pos|fdr` <= 0.05)

    shifrut_pos_genes <- alias_arbiter(
      IDs = shifrut_pos_genes$id, 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    # Create list object of genes
    goi_analysis <- read.csv(
        file.path(
          outputDir, 
          grep("_cart19_goi_data.csv", list.files(outputDir), value = TRUE)
        )
      ) %>%
      dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name)) 

    # GOI potential genes and analysis ----   
    potential_genes <- apply(
      as.matrix(goi_analysis[
        ,c("Depletion", "Enrichment", "Abundance", "Longitudinal")]), 
      2, function(x){
             goi_analysis$Gene_Name[x]
           })
    
    depletion_genes <- potential_genes$Depletion
    
    composite_genes <- unique(unlist(
      potential_genes[c("Enrichment", "Abundance", "Longitudinal")]))

    # Compare depletion genes to negative and composite genes to positive

    stats_tbl <- dplyr::bind_rows(lapply(
          c(1:2), 
          function(i, genes, pos_genes, neg_genes, total_considered){
            
            gene_set <- genes[[i]]
            
            # Normalize lists
            gene_set <- gene_set[gene_set %in% total_considered]
            not_gene_set <- total_considered[!total_considered %in% gene_set]
            
            if(i == 1){
              shi_genes <- neg_genes[neg_genes %in% total_considered]
            }else{
              shi_genes <- pos_genes[pos_genes %in% total_considered]
            }
            
            not_shi_genes <- total_considered[!total_considered %in% shi_genes]
            
            # Generate matrices
            gene_mat <- matrix(
              c(
                length(intersect(gene_set, shi_genes)),
                length(intersect(not_gene_set, shi_genes)),
                length(intersect(gene_set, not_shi_genes)),
                length(intersect(not_gene_set, not_shi_genes))
              ),
              ncol = 2
            )
            
            # Construct output data.frame
            data.frame(
              "gene.set" = names(genes)[[i]],
              "set.size" = length(gene_set),
              "shi.size" = length(shi_genes),
              "ovlp.size" = length(intersect(gene_set, shi_genes)),
              "enrich.odds" = fisher.test(gene_mat)$estimate,
              "enrich.pval" = fisher.test(gene_mat)$p.value,
              "ovlp.genes" = paste(
                intersect(gene_set, shi_genes), collapse = ";"
              )
            )
            
          },
          genes = list(
            "Depletion" = depletion_genes, "Composite" = composite_genes
          ),
          pos_genes = shifrut_pos_genes,
          neg_genes = shifrut_neg_genes,
          total_considered = total_overlapping_genes
        )
      )

  }
)

pander::pandoc.table(
  shifrut_comparison$stats_tbl, style = "simple", digits = 3, split.table = Inf
)
```

## Supplementary Figures. Patient-specific Longitudinal Observation of Clones

Written to file: /path/to/CART19_intsite_manuscript_analysis/reports/manuscript_figures/

```{r longitudinal_clone_plots, eval=TRUE}
long_clone_plots <- within(
  list(), {
    # Summarise each clones behavior
    clone_data <- as.data.frame(cond_uniq_sites, row.names = NULL) %>%
      dplyr::filter(patient %in% std_clin_patients) %>%
      dplyr::select(
        patient, timepoint, celltype, specimen, 
        estAbund, relAbund, posid, gene_id
      ) %>%
      dplyr::mutate(dtime = convert_time(as.character(timepoint))) %>%
      dplyr::group_by(patient, posid, gene_id) %>%
      dplyr::summarise(
        tfs = paste(sort(unique(as.integer(timepoint))), collapse = ","),
        min_tf = min(as.integer(timepoint)), 
        max_tf = max(as.integer(timepoint)),
        tps = paste(sort(unique(dtime)), collapse = ","),
        min_tp = min(dtime), max_tp = max(dtime),
        num_tp = n_distinct(timepoint),
        num_ct = n_distinct(celltype), num_sp = n_distinct(specimen),
        min_ab = min(estAbund), max_ab = max(estAbund),
        min_rb = min(relAbund), max_rb = max(relAbund)
      ) %>%
      dplyr::arrange(desc(num_tp), desc(max_ab), desc(min_ab)) %>%
      dplyr::ungroup()
    
    # Isolate data for plot
    plot_clones <- clone_data %>%
      dplyr::group_by(patient) %>%
      dplyr::arrange(desc(max_tp - min_tp), desc(max_rb)) %>%
      dplyr::slice(1:10) %$%
      unique(paste0(patient, ":", posid))

    plot_data <- as.data.frame(cond_uniq_sites, row.names = NULL) %>%
      dplyr::select(patient, timepoint, posid, gene_id, estAbund, relAbund) %>%
      dplyr::filter(paste0(patient, ":", posid) %in% plot_clones) %>%
      dplyr::mutate(
        tp = convert_time(as.character(timepoint)),
        tp = ifelse(tp == 0, 7.5, tp),
        tp = ifelse(tp == 1, 8.5, tp),
        pf = as.integer(
          factor(paste0(patient, ":", posid), levels = rev(plot_clones)))
      ) %>%
      dplyr::group_by(patient, timepoint, tp, pf, posid, gene_id) %>%
      dplyr::summarise(
        logAbund = log(mean(estAbund), base = 10),
        estAbund = mean(estAbund),
        relAbund = mean(relAbund)
      ) %>%
      dplyr::group_by(patient, posid, gene_id) %>%
      dplyr::mutate(num_tp = n_distinct(tp)) %>%
      dplyr::ungroup() %>%
      dplyr::group_by(num_tp) %>%
      dplyr::mutate(pf = as.integer(factor(pf, levels = sort(unique(pf))))) %>%
      dplyr::ungroup()

    # Formated for 7"w by 3"h
    split_plot_data <- split(plot_data, plot_data$patient)
     
    long_plots <- lapply(split_plot_data, function(df){
      
      df <- df %>%
        dplyr::arrange(desc(estAbund)) %>%
        dplyr::mutate(
          patient = paste0("Patient: ", patient),
          plot_id = paste0(gene_id, "\n", posid),
          plot_id = factor(plot_id, levels = unique(plot_id))
        )
      
      axis_breaks <- c(
        7.5, 10, 14, 28, 60, 90, 120, 240, 365, 730, 1095, 1826
      )
      
      axis_labels <- c(
        "TDN", "d10", "d14", "d28", "m2", "m3", "m4", "m8", 
        "y1", "y2", "y3", "y5"
      )
      
      max_tp <- max(df$tp)
      max_idx <- min(which(axis_breaks > max_tp))
      max_idx <- max(c(max_idx, 5))
      
      axis_breaks <- axis_breaks[seq_len(max_idx)]
      axis_labels <- axis_labels[seq_len(max_idx)]
      
      ggplot(df, aes(x = tp, y = relAbund)) +
        geom_line(aes(group = plot_id), alpha = 0.15) +
        geom_point(aes(color = plot_id), size = 2.5) +
        facet_grid(. ~ patient) +
        scale_color_brewer(type = "seq", palette = "Paired") +
        scale_x_log10(
          breaks = axis_breaks,
          labels = axis_labels,
          limits = c(7.5, max(df$tp))
        ) + 
        labs(
          x = "Treatment Time", 
          y = "Relative Abundance", 
          color = NULL
        ) +
        guides(
          color = guide_legend(
            direction = "vertical",
            keyheight = unit(0.27, units = "in"))
        ) +
        custom_theme +
        theme(
          legend.position = "right",
          legend.text = element_text(size = 7.5),
          axis.line.y = element_line(color = "black"),
          axis.line.x = element_line(color = "black"),
          axis.text.x = element_text(size = 9),
          strip.text.y = element_text(angle = 0)
        )
      
    })
    
    null <- lapply(seq_along(long_plots), function(i){
      
      file_pdf <- paste0("supfig.", names(long_plots)[i], ".long_plot.pdf")
      
      ggsave(
        filename = file_pdf, 
        plot = long_plots[[i]], 
        device = "pdf", 
        path = file.path(workingDir, "reports/manuscript_figures"), 
        width = 7, 
        height = 3, 
        units = "in"
      )
      
    })
    
})
```

